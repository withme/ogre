<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.7</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#integration">Integration of RTSS</a></li>
<li class="level1"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level1"><a href="#debugging">Tips for debugging shaders</a></li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full FFP (Fixed Function Pipeline) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D10, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="integration"></a>
Integration of RTSS</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Method to add a resource location to for a given resource group. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="comment">// Add a specialized sub-render (per-pixel lighting) state to the default scheme render state</span></div><div class="line">    <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* pMainRenderState = </div><div class="line">        mShaderGenerator-&gt;createOrRetrieveRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>).first;</div><div class="line">    pMainRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#a0ca983d7872dd4af086d73f1685188f1">reset</a>();</div><div class="line"></div><div class="line">    mShaderGenerator-&gt;addSubRenderStateFactory(<span class="keyword">new</span> <a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting_factory.html">Ogre::RTShader::PerPixelLightingFactory</a>);</div><div class="line">    pMainRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(</div><div class="line">        mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>));    </div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<img src="CreateShaderBasedTech.PNG" alt="CreateShaderBasedTech.PNG"/>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<img src="RuntimeShaderGeneration.PNG" alt="RuntimeShaderGeneration.PNG"/>
</div>
<h1>High system overview</h1>
<h1>Main components</h1>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h2>ShaderGenerator</h2>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h2>RenderState classes</h2>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h2>SubRenderState classes</h2>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p><b>Note:</b> There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h2>SubRenderStateFactory</h2>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h1><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h1>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>, internalCounter++);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h1><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h1>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
