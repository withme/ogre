<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::ManualObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.7</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_manual_object.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_ogre_1_1_manual_object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::ManualObject Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___scene.html">Scene</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class providing a much simplified interface to generating manual objects with custom geometry.  
 <a href="class_ogre_1_1_manual_object.html#details">More...</a></p>

<p><code>#include &lt;OgreManualObject.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::ManualObject:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_manual_object__inherit__graph.svg" width="455" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Built, renderable section of geometry.  <a href="class_ogre_1_1_manual_object_1_1_manual_object_section.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section_shadow_renderable.html">ManualObjectSectionShadowRenderable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nested class to allow shadows.  <a href="class_ogre_1_1_manual_object_1_1_manual_object_section_shadow_renderable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aed2302f68cdadd3f043d503eeeccd928"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#aed2302f68cdadd3f043d503eeeccd928">SectionList</a></td></tr>
<tr class="separator:aed2302f68cdadd3f043d503eeeccd928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84ea1b2728ced5136add26c91c39a27"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="class_ogre_1_1_shadow_renderable.html">ShadowRenderable</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_caster.html#ad84ea1b2728ced5136add26c91c39a27">ShadowRenderableList</a></td></tr>
<tr class="separator:ad84ea1b2728ced5136add26c91c39a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0999d33e25db97d0449d6cf95cbecd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt; <a class="el" href="class_ogre_1_1_shadow_caster.html#ad84ea1b2728ced5136add26c91c39a27">ShadowRenderableList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_caster.html#a7b0999d33e25db97d0449d6cf95cbecd">ShadowRenderableListIterator</a></td></tr>
<tr class="separator:a7b0999d33e25db97d0449d6cf95cbecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88d99ad5d5fdb5702f7a6b8c3fdd82af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a88d99ad5d5fdb5702f7a6b8c3fdd82af">ManualObject</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="separator:a88d99ad5d5fdb5702f7a6b8c3fdd82af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021bc790af45aaa6ce7f7505ea98ccd2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a021bc790af45aaa6ce7f7505ea98ccd2">~ManualObject</a> ()</td></tr>
<tr class="separator:a021bc790af45aaa6ce7f7505ea98ccd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cbeec62e231ef06f3527dd46d032f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_movable_object_factory.html">MovableObjectFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a01cbeec62e231ef06f3527dd46d032f0">_getCreator</a> (void) const </td></tr>
<tr class="memdesc:a01cbeec62e231ef06f3527dd46d032f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the creator of this object, if any (internal use only)  <a href="#a01cbeec62e231ef06f3527dd46d032f0">More...</a><br /></td></tr>
<tr class="separator:a01cbeec62e231ef06f3527dd46d032f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0982f88226f7793a9b289d33e4621f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a5b0982f88226f7793a9b289d33e4621f">_getLightList</a> ()</td></tr>
<tr class="memdesc:a5b0982f88226f7793a9b289d33e4621f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the current list of lights for this object.  <a href="#a5b0982f88226f7793a9b289d33e4621f">More...</a><br /></td></tr>
<tr class="separator:a5b0982f88226f7793a9b289d33e4621f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45888252f96cda04df97f1f6f98f45b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ac45888252f96cda04df97f1f6f98f45b">_getManager</a> (void) const </td></tr>
<tr class="memdesc:ac45888252f96cda04df97f1f6f98f45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manager of this object, if any (internal use only)  <a href="#ac45888252f96cda04df97f1f6f98f45b">More...</a><br /></td></tr>
<tr class="separator:ac45888252f96cda04df97f1f6f98f45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6d217065c5d2968ef0cc2586a0db86"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#aab6d217065c5d2968ef0cc2586a0db86">_getParentNodeFullTransform</a> (void) const </td></tr>
<tr class="memdesc:aab6d217065c5d2968ef0cc2586a0db86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full transformation of the parent sceneNode or the attachingPoint node.  <a href="#aab6d217065c5d2968ef0cc2586a0db86">More...</a><br /></td></tr>
<tr class="separator:aab6d217065c5d2968ef0cc2586a0db86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb13418fe2740ed8ebc52cd9667fca41"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#aeb13418fe2740ed8ebc52cd9667fca41">_notifyAttached</a> (<a class="el" href="class_ogre_1_1_node.html">Node</a> *parent, bool isTagPoint=false)</td></tr>
<tr class="memdesc:aeb13418fe2740ed8ebc52cd9667fca41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method called to notify the object that it has been attached to a node.  <a href="#aeb13418fe2740ed8ebc52cd9667fca41">More...</a><br /></td></tr>
<tr class="separator:aeb13418fe2740ed8ebc52cd9667fca41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f161ae0451be7eaa67e77c296d5631"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a06f161ae0451be7eaa67e77c296d5631">_notifyCreator</a> (<a class="el" href="class_ogre_1_1_movable_object_factory.html">MovableObjectFactory</a> *fact)</td></tr>
<tr class="memdesc:a06f161ae0451be7eaa67e77c296d5631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the object of it's creator (internal use only)  <a href="#a06f161ae0451be7eaa67e77c296d5631">More...</a><br /></td></tr>
<tr class="separator:a06f161ae0451be7eaa67e77c296d5631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa805908a2945ba1e1b1d6badb4761e27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#aa805908a2945ba1e1b1d6badb4761e27">_notifyCurrentCamera</a> (<a class="el" href="class_ogre_1_1_camera.html">Camera</a> *cam)</td></tr>
<tr class="memdesc:aa805908a2945ba1e1b1d6badb4761e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to notify the object of the camera to be used for the next rendering operation.  <a href="#aa805908a2945ba1e1b1d6badb4761e27">More...</a><br /></td></tr>
<tr class="separator:aa805908a2945ba1e1b1d6badb4761e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af730ac3ee4a51ee69f4221298f933e8a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#af730ac3ee4a51ee69f4221298f933e8a">_notifyManager</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *man)</td></tr>
<tr class="memdesc:af730ac3ee4a51ee69f4221298f933e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the object of it's manager (internal use only)  <a href="#af730ac3ee4a51ee69f4221298f933e8a">More...</a><br /></td></tr>
<tr class="separator:af730ac3ee4a51ee69f4221298f933e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae307c64b6e130191e45d48df0e2c5961"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ae307c64b6e130191e45d48df0e2c5961">_notifyMoved</a> (void)</td></tr>
<tr class="memdesc:ae307c64b6e130191e45d48df0e2c5961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method called to notify the object that it has been moved.  <a href="#ae307c64b6e130191e45d48df0e2c5961">More...</a><br /></td></tr>
<tr class="separator:ae307c64b6e130191e45d48df0e2c5961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748269201d1e2df008b7b1c37590ab24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a748269201d1e2df008b7b1c37590ab24">_releaseManualHardwareResources</a> ()</td></tr>
<tr class="memdesc:a748269201d1e2df008b7b1c37590ab24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the movable object that hardware resources were lost.  <a href="#a748269201d1e2df008b7b1c37590ab24">More...</a><br /></td></tr>
<tr class="separator:a748269201d1e2df008b7b1c37590ab24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5561a07f78291e327351fe83e64a9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#abd5561a07f78291e327351fe83e64a9b">_restoreManualHardwareResources</a> ()</td></tr>
<tr class="memdesc:abd5561a07f78291e327351fe83e64a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the movable object that hardware resources should be restored.  <a href="#abd5561a07f78291e327351fe83e64a9b">More...</a><br /></td></tr>
<tr class="separator:abd5561a07f78291e327351fe83e64a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2201138dbe5b3966a7704aaebbe7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#aeb2201138dbe5b3966a7704aaebbe7fe">_updateRenderQueue</a> (<a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *queue)</td></tr>
<tr class="memdesc:aeb2201138dbe5b3966a7704aaebbe7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method by which the movable object must add <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> subclass instances to the rendering queue.  <a href="#aeb2201138dbe5b3966a7704aaebbe7fe">More...</a><br /></td></tr>
<tr class="separator:aeb2201138dbe5b3966a7704aaebbe7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fe88f82f86eafa19308074495db809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a98fe88f82f86eafa19308074495db809">addQueryFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a98fe88f82f86eafa19308074495db809"><td class="mdescLeft">&#160;</td><td class="mdescRight">As setQueryFlags, except the flags passed as parameters are appended to the existing flags on this object.  <a href="#a98fe88f82f86eafa19308074495db809">More...</a><br /></td></tr>
<tr class="separator:a98fe88f82f86eafa19308074495db809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b823b52684730302908ecfd1a8e6d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a6b823b52684730302908ecfd1a8e6d54">addVisibilityFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a6b823b52684730302908ecfd1a8e6d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">As setVisibilityFlags, except the flags passed as parameters are appended to the existing flags on this object.  <a href="#a6b823b52684730302908ecfd1a8e6d54">More...</a><br /></td></tr>
<tr class="separator:a6b823b52684730302908ecfd1a8e6d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d5945478fbc7fa056cecd88fdf2781"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781">begin</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;materialName, <a class="el" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10d">RenderOperation::OperationType</a> opType=<a class="el" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10da8c00ee152b44fe8000c2fd675437c087">RenderOperation::OT_TRIANGLE_LIST</a>, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:a70d5945478fbc7fa056cecd88fdf2781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start defining a part of the object.  <a href="#a70d5945478fbc7fa056cecd88fdf2781">More...</a><br /></td></tr>
<tr class="separator:a70d5945478fbc7fa056cecd88fdf2781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4103359ee463b1a000623d9516291c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a0c4103359ee463b1a000623d9516291c">beginUpdate</a> (size_t sectionIndex)</td></tr>
<tr class="memdesc:a0c4103359ee463b1a000623d9516291c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the definition of an update to a part of the object.  <a href="#a0c4103359ee463b1a000623d9516291c">More...</a><br /></td></tr>
<tr class="separator:a0c4103359ee463b1a000623d9516291c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3a1d7a06fbf52829708b270a1f6dc8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#acd3a1d7a06fbf52829708b270a1f6dc8">clear</a> (void)</td></tr>
<tr class="memdesc:acd3a1d7a06fbf52829708b270a1f6dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely clear the contents of the object.  <a href="#acd3a1d7a06fbf52829708b270a1f6dc8">More...</a><br /></td></tr>
<tr class="separator:acd3a1d7a06fbf52829708b270a1f6dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790bf1eacf2c1c07bd663891fb6df39b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a790bf1eacf2c1c07bd663891fb6df39b">colour</a> (const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;col)</td></tr>
<tr class="memdesc:a790bf1eacf2c1c07bd663891fb6df39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex colour to a vertex.  <a href="#a790bf1eacf2c1c07bd663891fb6df39b">More...</a><br /></td></tr>
<tr class="separator:a790bf1eacf2c1c07bd663891fb6df39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07cde8a219635535b34622f7f22420"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a7c07cde8a219635535b34622f7f22420">colour</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> r, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> g, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> b, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> a=1.0f)</td></tr>
<tr class="separator:a7c07cde8a219635535b34622f7f22420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657275e617d9558951a3037f02b07efe"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a657275e617d9558951a3037f02b07efe">convertToMesh</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;meshName, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;groupName=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:a657275e617d9558951a3037f02b07efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert this object to a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a>.  <a href="#a657275e617d9558951a3037f02b07efe">More...</a><br /></td></tr>
<tr class="separator:a657275e617d9558951a3037f02b07efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cfac9af1b0d71c780ec969166b3585"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#a5e0882c3b9f7ca32a795f98cf034e428">AnimableValuePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_animable_object.html#ab2cfac9af1b0d71c780ec969166b3585">createAnimableValue</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;valueName)</td></tr>
<tr class="memdesc:ab2cfac9af1b0d71c780ec969166b3585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reference-counted AnimableValuePtr for the named value.  <a href="#ab2cfac9af1b0d71c780ec969166b3585">More...</a><br /></td></tr>
<tr class="separator:ab2cfac9af1b0d71c780ec969166b3585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b39d44e60020d43033a6957895aa5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a61b39d44e60020d43033a6957895aa5f">detachFromParent</a> (void)</td></tr>
<tr class="memdesc:a61b39d44e60020d43033a6957895aa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches an object from a parent <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>, if attached.  <a href="#a61b39d44e60020d43033a6957895aa5f">More...</a><br /></td></tr>
<tr class="separator:a61b39d44e60020d43033a6957895aa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d6bfe460ff1e0178c6d77b95d3dc5a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a49d6bfe460ff1e0178c6d77b95d3dc5a">end</a> (void)</td></tr>
<tr class="memdesc:a49d6bfe460ff1e0178c6d77b95d3dc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish defining the object and compile the final renderable version.  <a href="#a49d6bfe460ff1e0178c6d77b95d3dc5a">More...</a><br /></td></tr>
<tr class="separator:a49d6bfe460ff1e0178c6d77b95d3dc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59153e5ecd0f694c9ef143ad57ae082f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a59153e5ecd0f694c9ef143ad57ae082f">estimateIndexCount</a> (size_t icount)</td></tr>
<tr class="memdesc:a59153e5ecd0f694c9ef143ad57ae082f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the number of indices ahead of time.  <a href="#a59153e5ecd0f694c9ef143ad57ae082f">More...</a><br /></td></tr>
<tr class="separator:a59153e5ecd0f694c9ef143ad57ae082f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9448c472c45235366231ec1a6e4e5b73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a9448c472c45235366231ec1a6e4e5b73">estimateVertexCount</a> (size_t vcount)</td></tr>
<tr class="memdesc:a9448c472c45235366231ec1a6e4e5b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the number of vertices ahead of time.  <a href="#a9448c472c45235366231ec1a6e4e5b73">More...</a><br /></td></tr>
<tr class="separator:a9448c472c45235366231ec1a6e4e5b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4239d192b2b08c4970dfaa22ce5a0cd0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_animable_object.html#a4239d192b2b08c4970dfaa22ce5a0cd0">getAnimableValueNames</a> (void) const </td></tr>
<tr class="memdesc:a4239d192b2b08c4970dfaa22ce5a0cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of animable value names for this object.  <a href="#a4239d192b2b08c4970dfaa22ce5a0cd0">More...</a><br /></td></tr>
<tr class="separator:a4239d192b2b08c4970dfaa22ce5a0cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e0402c8f0729b259e8370ea4188cbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ad6e0402c8f0729b259e8370ea4188cbb">getBoundingBox</a> (void) const </td></tr>
<tr class="memdesc:ad6e0402c8f0729b259e8370ea4188cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the local axis-aligned bounding box for this object.  <a href="#ad6e0402c8f0729b259e8370ea4188cbb">More...</a><br /></td></tr>
<tr class="separator:ad6e0402c8f0729b259e8370ea4188cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7af7e372a27337225bcac207ea81c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ab7af7e372a27337225bcac207ea81c9c">getBoundingRadius</a> (void) const </td></tr>
<tr class="memdesc:ab7af7e372a27337225bcac207ea81c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the radius of the origin-centered bounding sphere for this object.  <a href="#ab7af7e372a27337225bcac207ea81c9c">More...</a><br /></td></tr>
<tr class="separator:ab7af7e372a27337225bcac207ea81c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bca10cdeac93142d9f93ed0cf9c4c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a70bca10cdeac93142d9f93ed0cf9c4c5">getCastShadows</a> (void) const </td></tr>
<tr class="memdesc:a70bca10cdeac93142d9f93ed0cf9c4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether shadow casting is enabled for this object.  <a href="#a70bca10cdeac93142d9f93ed0cf9c4c5">More...</a><br /></td></tr>
<tr class="separator:a70bca10cdeac93142d9f93ed0cf9c4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237bbc1d4e569e58ab971384be37fc42"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a237bbc1d4e569e58ab971384be37fc42">getCurrentIndexCount</a> () const </td></tr>
<tr class="memdesc:a237bbc1d4e569e58ab971384be37fc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indices in the section currently being defined (returns 0 if no section is in progress).  <a href="#a237bbc1d4e569e58ab971384be37fc42">More...</a><br /></td></tr>
<tr class="separator:a237bbc1d4e569e58ab971384be37fc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6155692f6b3873234c2f5a20e18c643"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ab6155692f6b3873234c2f5a20e18c643">getCurrentVertexCount</a> () const </td></tr>
<tr class="memdesc:ab6155692f6b3873234c2f5a20e18c643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices in the section currently being defined (returns 0 if no section is in progress).  <a href="#ab6155692f6b3873234c2f5a20e18c643">More...</a><br /></td></tr>
<tr class="separator:ab6155692f6b3873234c2f5a20e18c643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06612d0607ebcf1bf5eb817c3038d52"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#af06612d0607ebcf1bf5eb817c3038d52">getDarkCapBounds</a> (const <a class="el" href="class_ogre_1_1_light.html">Light</a> &amp;light, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> dirLightExtrusionDist) const </td></tr>
<tr class="memdesc:af06612d0607ebcf1bf5eb817c3038d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden member from <a class="el" href="class_ogre_1_1_shadow_caster.html" title="This class defines the interface that must be implemented by shadow casters. ">ShadowCaster</a>.  <a href="#af06612d0607ebcf1bf5eb817c3038d52">More...</a><br /></td></tr>
<tr class="separator:af06612d0607ebcf1bf5eb817c3038d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1404661a0e201ad6171cd0d35c036297"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a1404661a0e201ad6171cd0d35c036297">getDynamic</a> () const </td></tr>
<tr class="memdesc:a1404661a0e201ad6171cd0d35c036297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether this object is marked as dynamic.  <a href="#a1404661a0e201ad6171cd0d35c036297">More...</a><br /></td></tr>
<tr class="separator:a1404661a0e201ad6171cd0d35c036297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53798ccf0c34105122ee77dad0904d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_edge_data.html">EdgeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a5a53798ccf0c34105122ee77dad0904d">getEdgeList</a> (void)</td></tr>
<tr class="memdesc:a5a53798ccf0c34105122ee77dad0904d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to enable stencil shadows.  <a href="#a5a53798ccf0c34105122ee77dad0904d">More...</a><br /></td></tr>
<tr class="separator:a5a53798ccf0c34105122ee77dad0904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b516742f7f117b8e8a2eec7187adc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ad9b516742f7f117b8e8a2eec7187adc3">getKeepDeclarationOrder</a> () const </td></tr>
<tr class="memdesc:ad9b516742f7f117b8e8a2eec7187adc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether or not the declaration order is to be kept or not.  <a href="#ad9b516742f7f117b8e8a2eec7187adc3">More...</a><br /></td></tr>
<tr class="separator:ad9b516742f7f117b8e8a2eec7187adc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af061175eb50a6aa98599ce0a748204b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#af061175eb50a6aa98599ce0a748204b5">getLightCapBounds</a> (void) const </td></tr>
<tr class="memdesc:af061175eb50a6aa98599ce0a748204b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden member from <a class="el" href="class_ogre_1_1_shadow_caster.html" title="This class defines the interface that must be implemented by shadow casters. ">ShadowCaster</a>.  <a href="#af061175eb50a6aa98599ce0a748204b5">More...</a><br /></td></tr>
<tr class="separator:af061175eb50a6aa98599ce0a748204b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a96239224e96845b323fb73fed8bff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a59a96239224e96845b323fb73fed8bff">getLightMask</a> () const </td></tr>
<tr class="memdesc:a59a96239224e96845b323fb73fed8bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bitwise mask which will filter the lights affecting this object.  <a href="#a59a96239224e96845b323fb73fed8bff">More...</a><br /></td></tr>
<tr class="separator:a59a96239224e96845b323fb73fed8bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8f2ff3a40138fa21d0058892a4db74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_movable_object_1_1_listener.html">Listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a6c8f2ff3a40138fa21d0058892a4db74">getListener</a> (void) const </td></tr>
<tr class="memdesc:a6c8f2ff3a40138fa21d0058892a4db74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current listener for this object.  <a href="#a6c8f2ff3a40138fa21d0058892a4db74">More...</a><br /></td></tr>
<tr class="separator:a6c8f2ff3a40138fa21d0058892a4db74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd2accb4a7bfbe56028b2a380cbf371"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a9bd2accb4a7bfbe56028b2a380cbf371">getMovableType</a> (void) const </td></tr>
<tr class="memdesc:a9bd2accb4a7bfbe56028b2a380cbf371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type name of this object.  <a href="#a9bd2accb4a7bfbe56028b2a380cbf371">More...</a><br /></td></tr>
<tr class="separator:a9bd2accb4a7bfbe56028b2a380cbf371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24af8a9f885f5dd12dbb00407e30050e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a24af8a9f885f5dd12dbb00407e30050e">getName</a> (void) const </td></tr>
<tr class="memdesc:a24af8a9f885f5dd12dbb00407e30050e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this object.  <a href="#a24af8a9f885f5dd12dbb00407e30050e">More...</a><br /></td></tr>
<tr class="separator:a24af8a9f885f5dd12dbb00407e30050e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97ea7aa7bc3368eeef26e35faaf5f62"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ad97ea7aa7bc3368eeef26e35faaf5f62">getNumSections</a> (void) const </td></tr>
<tr class="memdesc:ad97ea7aa7bc3368eeef26e35faaf5f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html" title="Built, renderable section of geometry. ">ManualObjectSection</a> objects making up this <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">ManualObject</a>.  <a href="#ad97ea7aa7bc3368eeef26e35faaf5f62">More...</a><br /></td></tr>
<tr class="separator:ad97ea7aa7bc3368eeef26e35faaf5f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b5ce572f51a41e31d72edd0c6fcf6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a96b5ce572f51a41e31d72edd0c6fcf6e">getParentNode</a> (void) const </td></tr>
<tr class="memdesc:a96b5ce572f51a41e31d72edd0c6fcf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node to which this object is attached.  <a href="#a96b5ce572f51a41e31d72edd0c6fcf6e">More...</a><br /></td></tr>
<tr class="separator:a96b5ce572f51a41e31d72edd0c6fcf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f09f421fc7f9827844f6bb138360f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#aa8f09f421fc7f9827844f6bb138360f5">getParentSceneNode</a> (void) const </td></tr>
<tr class="memdesc:aa8f09f421fc7f9827844f6bb138360f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scene node to which this object is attached.  <a href="#aa8f09f421fc7f9827844f6bb138360f5">More...</a><br /></td></tr>
<tr class="separator:aa8f09f421fc7f9827844f6bb138360f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb13b8e1b52d9dca9f5190f718686a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#abb13b8e1b52d9dca9f5190f718686a5e">getPointExtrusionDistance</a> (const <a class="el" href="class_ogre_1_1_light.html">Light</a> *l) const </td></tr>
<tr class="memdesc:abb13b8e1b52d9dca9f5190f718686a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the distance to extrude for a point/spot light.  <a href="#abb13b8e1b52d9dca9f5190f718686a5e">More...</a><br /></td></tr>
<tr class="separator:abb13b8e1b52d9dca9f5190f718686a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e39e9322a3c96030148b3bae233de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a365e39e9322a3c96030148b3bae233de">getQueryFlags</a> (void) const </td></tr>
<tr class="memdesc:a365e39e9322a3c96030148b3bae233de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the query flags relevant for this object.  <a href="#a365e39e9322a3c96030148b3bae233de">More...</a><br /></td></tr>
<tr class="separator:a365e39e9322a3c96030148b3bae233de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2627b8d1658838a7c79c82148c6303"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a8f2627b8d1658838a7c79c82148c6303">getReceivesShadows</a> ()</td></tr>
<tr class="memdesc:a8f2627b8d1658838a7c79c82148c6303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> of any <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> that this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will add to the render queue will receive shadows.  <a href="#a8f2627b8d1658838a7c79c82148c6303">More...</a><br /></td></tr>
<tr class="separator:a8f2627b8d1658838a7c79c82148c6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf66828e73b2248f723574b9096398d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#acf66828e73b2248f723574b9096398d2">getRenderingDistance</a> (void) const </td></tr>
<tr class="memdesc:acf66828e73b2248f723574b9096398d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance at which batches are no longer rendered.  <a href="#acf66828e73b2248f723574b9096398d2">More...</a><br /></td></tr>
<tr class="separator:acf66828e73b2248f723574b9096398d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b928de7466910e0cc8513c15fd492c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a01b928de7466910e0cc8513c15fd492c">getRenderingMinPixelSize</a> () const </td></tr>
<tr class="memdesc:a01b928de7466910e0cc8513c15fd492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum pixel size an object needs to be in both screen axes in order to be rendered.  <a href="#a01b928de7466910e0cc8513c15fd492c">More...</a><br /></td></tr>
<tr class="separator:a01b928de7466910e0cc8513c15fd492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab84842614331bde8bdd3e756456698"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#abab84842614331bde8bdd3e756456698">getRenderQueueGroup</a> (void) const </td></tr>
<tr class="memdesc:abab84842614331bde8bdd3e756456698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the queue group for this entity.  <a href="#abab84842614331bde8bdd3e756456698">More...</a><br /></td></tr>
<tr class="separator:abab84842614331bde8bdd3e756456698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583626e6d061aa7751dd9c840c9067cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a583626e6d061aa7751dd9c840c9067cd">getSection</a> (unsigned int <a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d">index</a>) const </td></tr>
<tr class="memdesc:a583626e6d061aa7751dd9c840c9067cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to a <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html" title="Built, renderable section of geometry. ">ManualObjectSection</a>, i.e.  <a href="#a583626e6d061aa7751dd9c840c9067cd">More...</a><br /></td></tr>
<tr class="separator:a583626e6d061aa7751dd9c840c9067cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87917ee5f2096373753098bfc2e179cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_shadow_caster.html#a7b0999d33e25db97d0449d6cf95cbecd">ShadowRenderableListIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a87917ee5f2096373753098bfc2e179cf">getShadowVolumeRenderableIterator</a> (<a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a> shadowTechnique, const <a class="el" href="class_ogre_1_1_light.html">Light</a> *light, <a class="el" href="class_ogre_1_1_hardware_index_buffer_shared_ptr.html">HardwareIndexBufferSharedPtr</a> *indexBuffer, size_t *indexBufferUsedSize, bool <a class="el" href="class_ogre_1_1_shadow_caster.html#acae2215c051989d544f34083a0a9bfa2">extrudeVertices</a>, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> extrusionDist, unsigned long flags=0)</td></tr>
<tr class="memdesc:a87917ee5f2096373753098bfc2e179cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this method to enable stencil shadows.  <a href="#a87917ee5f2096373753098bfc2e179cf">More...</a><br /></td></tr>
<tr class="separator:a87917ee5f2096373753098bfc2e179cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c637889b8a4138d2008aece76f42b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a32c637889b8a4138d2008aece76f42b6">getTypeFlags</a> (void) const </td></tr>
<tr class="memdesc:a32c637889b8a4138d2008aece76f42b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 'type flags' for this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>.  <a href="#a32c637889b8a4138d2008aece76f42b6">More...</a><br /></td></tr>
<tr class="separator:a32c637889b8a4138d2008aece76f42b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b0416a4bde818687699da8c73d51f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a54b0416a4bde818687699da8c73d51f1">getUseIdentityProjection</a> (void) const </td></tr>
<tr class="memdesc:a54b0416a4bde818687699da8c73d51f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not to use an 'identity' projection.  <a href="#a54b0416a4bde818687699da8c73d51f1">More...</a><br /></td></tr>
<tr class="separator:a54b0416a4bde818687699da8c73d51f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79071ea0007acab8f18cb4c6ffc6eaf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a79071ea0007acab8f18cb4c6ffc6eaf9">getUseIdentityView</a> (void) const </td></tr>
<tr class="memdesc:a79071ea0007acab8f18cb4c6ffc6eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not to use an 'identity' view.  <a href="#a79071ea0007acab8f18cb4c6ffc6eaf9">More...</a><br /></td></tr>
<tr class="separator:a79071ea0007acab8f18cb4c6ffc6eaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e745d2a09637903b91912419e00a52"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ad9e745d2a09637903b91912419e00a52">getUserAny</a> (void) const </td></tr>
<tr class="separator:ad9e745d2a09637903b91912419e00a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac5bf65835f733433f3338132f2f01f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#aaac5bf65835f733433f3338132f2f01f">getUserObjectBindings</a> ()</td></tr>
<tr class="memdesc:aaac5bf65835f733433f3338132f2f01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#aaac5bf65835f733433f3338132f2f01f">More...</a><br /></td></tr>
<tr class="separator:aaac5bf65835f733433f3338132f2f01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf5cf5545c219ce9be1997ff5dd2204"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#abbf5cf5545c219ce9be1997ff5dd2204">getUserObjectBindings</a> () const </td></tr>
<tr class="memdesc:abbf5cf5545c219ce9be1997ff5dd2204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instance of user objects binding associated with this class.  <a href="#abbf5cf5545c219ce9be1997ff5dd2204">More...</a><br /></td></tr>
<tr class="separator:abbf5cf5545c219ce9be1997ff5dd2204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074c223d5622dd338c1ea46d9802b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a8074c223d5622dd338c1ea46d9802b37">getVisibilityFlags</a> (void) const </td></tr>
<tr class="memdesc:a8074c223d5622dd338c1ea46d9802b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the visibility flags relevant for this object.  <a href="#a8074c223d5622dd338c1ea46d9802b37">More...</a><br /></td></tr>
<tr class="separator:a8074c223d5622dd338c1ea46d9802b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc231df154e2a639cfe42df49947c03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a8cc231df154e2a639cfe42df49947c03">getVisible</a> (void) const </td></tr>
<tr class="memdesc:a8cc231df154e2a639cfe42df49947c03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets this object whether to be visible or not, if it has a renderable component.  <a href="#a8cc231df154e2a639cfe42df49947c03">More...</a><br /></td></tr>
<tr class="separator:a8cc231df154e2a639cfe42df49947c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc31c877990c3c231c4b4cfb0522bef8"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#acc31c877990c3c231c4b4cfb0522bef8">getWorldBoundingBox</a> (bool derive=false) const </td></tr>
<tr class="memdesc:acc31c877990c3c231c4b4cfb0522bef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the axis-aligned bounding box for this object in world coordinates.  <a href="#acc31c877990c3c231c4b4cfb0522bef8">More...</a><br /></td></tr>
<tr class="separator:acc31c877990c3c231c4b4cfb0522bef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6db9f0db4038e6544d703a9f3bcf53"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a2f6db9f0db4038e6544d703a9f3bcf53">getWorldBoundingSphere</a> (bool derive=false) const </td></tr>
<tr class="memdesc:a2f6db9f0db4038e6544d703a9f3bcf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the worldspace bounding sphere for this object.  <a href="#a2f6db9f0db4038e6544d703a9f3bcf53">More...</a><br /></td></tr>
<tr class="separator:a2f6db9f0db4038e6544d703a9f3bcf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b98b65fbf51b3b611b4e423c74fe79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a77b98b65fbf51b3b611b4e423c74fe79">hasEdgeList</a> (void)</td></tr>
<tr class="memdesc:a77b98b65fbf51b3b611b4e423c74fe79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridden member from <a class="el" href="class_ogre_1_1_shadow_caster.html" title="This class defines the interface that must be implemented by shadow casters. ">ShadowCaster</a>.  <a href="#a77b98b65fbf51b3b611b4e423c74fe79">More...</a><br /></td></tr>
<tr class="separator:a77b98b65fbf51b3b611b4e423c74fe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadcdf04053511d97e7e29848c6eef3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d">index</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> idx)</td></tr>
<tr class="memdesc:acadcdf04053511d97e7e29848c6eef3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list of vertices.  <a href="#acadcdf04053511d97e7e29848c6eef3d">More...</a><br /></td></tr>
<tr class="separator:acadcdf04053511d97e7e29848c6eef3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40bba3d61d14e27a9cc86ac93c007df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#af40bba3d61d14e27a9cc86ac93c007df">isAttached</a> (void) const </td></tr>
<tr class="memdesc:af40bba3d61d14e27a9cc86ac93c007df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>.  <a href="#af40bba3d61d14e27a9cc86ac93c007df">More...</a><br /></td></tr>
<tr class="separator:af40bba3d61d14e27a9cc86ac93c007df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146a71f594b7867c6c011e7c691d47f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a146a71f594b7867c6c011e7c691d47f6">isDebugDisplayEnabled</a> (void) const </td></tr>
<tr class="memdesc:a146a71f594b7867c6c011e7c691d47f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether debug display of this object is enabled.  <a href="#a146a71f594b7867c6c011e7c691d47f6">More...</a><br /></td></tr>
<tr class="separator:a146a71f594b7867c6c011e7c691d47f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605cb18ec6d5971e19491ec71c89afeb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a605cb18ec6d5971e19491ec71c89afeb">isInScene</a> (void) const </td></tr>
<tr class="memdesc:a605cb18ec6d5971e19491ec71c89afeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this object is attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>, and this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> / <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a> is currently in an active part of the scene graph.  <a href="#a605cb18ec6d5971e19491ec71c89afeb">More...</a><br /></td></tr>
<tr class="separator:a605cb18ec6d5971e19491ec71c89afeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe660d572f96913e2e3434440a342f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a5fe660d572f96913e2e3434440a342f3">isParentTagPoint</a> () const </td></tr>
<tr class="memdesc:a5fe660d572f96913e2e3434440a342f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the parent node is a <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a> (or a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>)  <a href="#a5fe660d572f96913e2e3434440a342f3">More...</a><br /></td></tr>
<tr class="separator:a5fe660d572f96913e2e3434440a342f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb41fb7484f365c18e78103517b0d25"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#aebb41fb7484f365c18e78103517b0d25">isVisible</a> (void) const </td></tr>
<tr class="memdesc:aebb41fb7484f365c18e78103517b0d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this object is supposed to be visible or not.  <a href="#aebb41fb7484f365c18e78103517b0d25">More...</a><br /></td></tr>
<tr class="separator:aebb41fb7484f365c18e78103517b0d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c0b0a41e2a4ced5ff89589c9a924a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1">normal</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;norm)</td></tr>
<tr class="memdesc:a59c0b0a41e2a4ced5ff89589c9a924a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex normal to the current vertex.  <a href="#a59c0b0a41e2a4ced5ff89589c9a924a1">More...</a><br /></td></tr>
<tr class="separator:a59c0b0a41e2a4ced5ff89589c9a924a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3960a89127a745b20310f00cb8526549"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a3960a89127a745b20310f00cb8526549">normal</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:a3960a89127a745b20310f00cb8526549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9986bd2627b75deeba14636c81efcde0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0">position</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos)</td></tr>
<tr class="memdesc:a9986bd2627b75deeba14636c81efcde0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex position, starting a new vertex at the same time.  <a href="#a9986bd2627b75deeba14636c81efcde0">More...</a><br /></td></tr>
<tr class="separator:a9986bd2627b75deeba14636c81efcde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57455f9489a4afb834de1832f04bfc31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a57455f9489a4afb834de1832f04bfc31">position</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:a57455f9489a4afb834de1832f04bfc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac70dbc6f35180d5c8bab671c3f2257"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a1ac70dbc6f35180d5c8bab671c3f2257">quad</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i1, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i2, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i3, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i4)</td></tr>
<tr class="memdesc:a1ac70dbc6f35180d5c8bab671c3f2257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of 4 vertex indices to construct a quad (out of 2 triangles); this is a shortcut to calling <a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d" title="Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list...">index()</a> 6 times, or <a class="el" href="class_ogre_1_1_manual_object.html#a573c1c83b42950a7c040f833236c6531" title="Add a set of 3 vertex indices to construct a triangle; this is a shortcut to calling index() 3 times...">triangle()</a> twice.  <a href="#a1ac70dbc6f35180d5c8bab671c3f2257">More...</a><br /></td></tr>
<tr class="separator:a1ac70dbc6f35180d5c8bab671c3f2257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36b81e590cb83df86ba68f8b0b2c5c9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ab36b81e590cb83df86ba68f8b0b2c5c9">queryLights</a> (void) const </td></tr>
<tr class="memdesc:ab36b81e590cb83df86ba68f8b0b2c5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a list of lights, ordered relative to how close they are to this movable object.  <a href="#ab36b81e590cb83df86ba68f8b0b2c5c9">More...</a><br /></td></tr>
<tr class="separator:ab36b81e590cb83df86ba68f8b0b2c5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb94e1627676c7d7517e13944bd0580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a6fb94e1627676c7d7517e13944bd0580">removeQueryFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a6fb94e1627676c7d7517e13944bd0580"><td class="mdescLeft">&#160;</td><td class="mdescRight">As setQueryFlags, except the flags passed as parameters are removed from the existing flags on this object.  <a href="#a6fb94e1627676c7d7517e13944bd0580">More...</a><br /></td></tr>
<tr class="separator:a6fb94e1627676c7d7517e13944bd0580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504e2192036f75007c51e157315e1548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a504e2192036f75007c51e157315e1548">removeVisibilityFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a504e2192036f75007c51e157315e1548"><td class="mdescLeft">&#160;</td><td class="mdescRight">As setVisibilityFlags, except the flags passed as parameters are removed from the existing flags on this object.  <a href="#a504e2192036f75007c51e157315e1548">More...</a><br /></td></tr>
<tr class="separator:a504e2192036f75007c51e157315e1548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a840aa95ae13acb026db417b86b4f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a44a840aa95ae13acb026db417b86b4f8">setBoundingBox</a> (const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;box)</td></tr>
<tr class="memdesc:a44a840aa95ae13acb026db417b86b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the bounding box.  <a href="#a44a840aa95ae13acb026db417b86b4f8">More...</a><br /></td></tr>
<tr class="separator:a44a840aa95ae13acb026db417b86b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfc4840224e8b6ed6e27849d3341675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a> (bool enabled)</td></tr>
<tr class="memdesc:acbfc4840224e8b6ed6e27849d3341675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not this object will cast shadows.  <a href="#acbfc4840224e8b6ed6e27849d3341675">More...</a><br /></td></tr>
<tr class="separator:acbfc4840224e8b6ed6e27849d3341675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa798ac114550b95d04fb0798ba1d94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#acaa798ac114550b95d04fb0798ba1d94">setDebugDisplayEnabled</a> (bool enabled)</td></tr>
<tr class="memdesc:acaa798ac114550b95d04fb0798ba1d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not the debug display of this object is enabled.  <a href="#acaa798ac114550b95d04fb0798ba1d94">More...</a><br /></td></tr>
<tr class="separator:acaa798ac114550b95d04fb0798ba1d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83143f157514a3bb44e325df19fdefde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a83143f157514a3bb44e325df19fdefde">setDynamic</a> (bool dyn)</td></tr>
<tr class="memdesc:a83143f157514a3bb44e325df19fdefde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use before defining geometry to indicate that you intend to update the geometry regularly and want the internal structure to reflect that.  <a href="#a83143f157514a3bb44e325df19fdefde">More...</a><br /></td></tr>
<tr class="separator:a83143f157514a3bb44e325df19fdefde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0b959647ec405c9e2b95c86a674378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#aaf0b959647ec405c9e2b95c86a674378">setKeepDeclarationOrder</a> (bool keepOrder)</td></tr>
<tr class="memdesc:aaf0b959647ec405c9e2b95c86a674378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not to keep the original declaration order when queuing the renderables.  <a href="#aaf0b959647ec405c9e2b95c86a674378">More...</a><br /></td></tr>
<tr class="separator:aaf0b959647ec405c9e2b95c86a674378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456ecd630d55c91b2fd1b19969d29f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a5456ecd630d55c91b2fd1b19969d29f5">setLightMask</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> lightMask)</td></tr>
<tr class="memdesc:a5456ecd630d55c91b2fd1b19969d29f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a bitwise mask which will filter the lights affecting this object.  <a href="#a5456ecd630d55c91b2fd1b19969d29f5">More...</a><br /></td></tr>
<tr class="separator:a5456ecd630d55c91b2fd1b19969d29f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55eab7ca8e96a3bbb3f69a4095bf067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ab55eab7ca8e96a3bbb3f69a4095bf067">setListener</a> (<a class="el" href="class_ogre_1_1_movable_object_1_1_listener.html">Listener</a> *listener)</td></tr>
<tr class="memdesc:ab55eab7ca8e96a3bbb3f69a4095bf067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a listener for this object.  <a href="#ab55eab7ca8e96a3bbb3f69a4095bf067">More...</a><br /></td></tr>
<tr class="separator:ab55eab7ca8e96a3bbb3f69a4095bf067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a3cc60f094ea252621023f084887b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ad67a3cc60f094ea252621023f084887b">setMaterialName</a> (size_t subIndex, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;group=<a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>)</td></tr>
<tr class="memdesc:ad67a3cc60f094ea252621023f084887b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the material for a subsection of this object after it has been specified.  <a href="#ad67a3cc60f094ea252621023f084887b">More...</a><br /></td></tr>
<tr class="separator:ad67a3cc60f094ea252621023f084887b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77198e02dd65dd368ea4e6af88a93fda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a77198e02dd65dd368ea4e6af88a93fda">setQueryFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a77198e02dd65dd368ea4e6af88a93fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the query flags for this object.  <a href="#a77198e02dd65dd368ea4e6af88a93fda">More...</a><br /></td></tr>
<tr class="separator:a77198e02dd65dd368ea4e6af88a93fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1f2a1009e3f14f36e1bcc9b1b9557e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#afe1f2a1009e3f14f36e1bcc9b1b9557e">setRenderingDistance</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> dist)</td></tr>
<tr class="memdesc:afe1f2a1009e3f14f36e1bcc9b1b9557e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distance at which the object is no longer rendered.  <a href="#afe1f2a1009e3f14f36e1bcc9b1b9557e">More...</a><br /></td></tr>
<tr class="separator:afe1f2a1009e3f14f36e1bcc9b1b9557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43f57e9abcc21d4bc50e6e6d1b5cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a4d43f57e9abcc21d4bc50e6e6d1b5cc7">setRenderingMinPixelSize</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> pixelSize)</td></tr>
<tr class="memdesc:a4d43f57e9abcc21d4bc50e6e6d1b5cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the minimum pixel size an object needs to be in both screen axes in order to be rendered.  <a href="#a4d43f57e9abcc21d4bc50e6e6d1b5cc7">More...</a><br /></td></tr>
<tr class="separator:a4d43f57e9abcc21d4bc50e6e6d1b5cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e898937867475e52d350d1f4d75e32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ac5e898937867475e52d350d1f4d75e32">setRenderQueueGroup</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> queueID)</td></tr>
<tr class="memdesc:ac5e898937867475e52d350d1f4d75e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the render queue group this entity will be rendered through.  <a href="#ac5e898937867475e52d350d1f4d75e32">More...</a><br /></td></tr>
<tr class="separator:ac5e898937867475e52d350d1f4d75e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cf564fe839d40a81ba5155d363b7aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a38cf564fe839d40a81ba5155d363b7aa">setRenderQueueGroupAndPriority</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> queueID, <a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a> priority)</td></tr>
<tr class="memdesc:a38cf564fe839d40a81ba5155d363b7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the render queue group and group priority this entity will be rendered through.  <a href="#a38cf564fe839d40a81ba5155d363b7aa">More...</a><br /></td></tr>
<tr class="separator:a38cf564fe839d40a81ba5155d363b7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f832d5605c489db7be396ec7cd20b85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a7f832d5605c489db7be396ec7cd20b85">setUseIdentityProjection</a> (bool useIdentityProjection)</td></tr>
<tr class="memdesc:a7f832d5605c489db7be396ec7cd20b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not to use an 'identity' projection.  <a href="#a7f832d5605c489db7be396ec7cd20b85">More...</a><br /></td></tr>
<tr class="separator:a7f832d5605c489db7be396ec7cd20b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b01abfbb1b9ef4c6d9e747d6474116c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a6b01abfbb1b9ef4c6d9e747d6474116c">setUseIdentityView</a> (bool useIdentityView)</td></tr>
<tr class="memdesc:a6b01abfbb1b9ef4c6d9e747d6474116c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether or not to use an 'identity' view.  <a href="#a6b01abfbb1b9ef4c6d9e747d6474116c">More...</a><br /></td></tr>
<tr class="separator:a6b01abfbb1b9ef4c6d9e747d6474116c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad93e3514b969971213ff4ae80103dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a1ad93e3514b969971213ff4ae80103dc">setUserAny</a> (const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;anything)</td></tr>
<tr class="separator:a1ad93e3514b969971213ff4ae80103dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b12f8d0fd7c9da7fcd1e9806dd8064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a28b12f8d0fd7c9da7fcd1e9806dd8064">setVisibilityFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a28b12f8d0fd7c9da7fcd1e9806dd8064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the visibility flags for this object.  <a href="#a28b12f8d0fd7c9da7fcd1e9806dd8064">More...</a><br /></td></tr>
<tr class="separator:a28b12f8d0fd7c9da7fcd1e9806dd8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad563191e86e4d119c62ea9acfc2a90d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ad563191e86e4d119c62ea9acfc2a90d5">setVisible</a> (bool visible)</td></tr>
<tr class="memdesc:ad563191e86e4d119c62ea9acfc2a90d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells this object whether to be visible or not, if it has a renderable component.  <a href="#ad563191e86e4d119c62ea9acfc2a90d5">More...</a><br /></td></tr>
<tr class="separator:ad563191e86e4d119c62ea9acfc2a90d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523bf713b8f94d325222d673f2be9518"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a523bf713b8f94d325222d673f2be9518">tangent</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;tan)</td></tr>
<tr class="memdesc:a523bf713b8f94d325222d673f2be9518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex tangent to the current vertex.  <a href="#a523bf713b8f94d325222d673f2be9518">More...</a><br /></td></tr>
<tr class="separator:a523bf713b8f94d325222d673f2be9518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8365a3dc159928c14824aa65b17585c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a8365a3dc159928c14824aa65b17585c7">tangent</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z)</td></tr>
<tr class="separator:a8365a3dc159928c14824aa65b17585c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d11e958d58e5db69e131aaad928fb80"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a1d11e958d58e5db69e131aaad928fb80">textureCoord</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> u)</td></tr>
<tr class="memdesc:a1d11e958d58e5db69e131aaad928fb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a texture coordinate to the current vertex.  <a href="#a1d11e958d58e5db69e131aaad928fb80">More...</a><br /></td></tr>
<tr class="separator:a1d11e958d58e5db69e131aaad928fb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e9cf451570dbf5f5f3ff0c7bd2962a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ac9e9cf451570dbf5f5f3ff0c7bd2962a">textureCoord</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> u, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> v)</td></tr>
<tr class="separator:ac9e9cf451570dbf5f5f3ff0c7bd2962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896e08b7414ed011e6804d22478fb010"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a896e08b7414ed011e6804d22478fb010">textureCoord</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> u, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> v, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> w)</td></tr>
<tr class="separator:a896e08b7414ed011e6804d22478fb010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc068c843bb3d5c535ad2f2b936fcf5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a7cc068c843bb3d5c535ad2f2b936fcf5">textureCoord</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> x, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> y, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> z, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> w)</td></tr>
<tr class="separator:a7cc068c843bb3d5c535ad2f2b936fcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57231f12ab74f84e902f0b807018a64"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ab57231f12ab74f84e902f0b807018a64">textureCoord</a> (const <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &amp;uv)</td></tr>
<tr class="separator:ab57231f12ab74f84e902f0b807018a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada31136462c099a7d766a42b3e246050"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ada31136462c099a7d766a42b3e246050">textureCoord</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;uvw)</td></tr>
<tr class="separator:ada31136462c099a7d766a42b3e246050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07dd511487c9affe72695b34cd2cdbf8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a07dd511487c9affe72695b34cd2cdbf8">textureCoord</a> (const <a class="el" href="class_ogre_1_1_vector4.html">Vector4</a> &amp;xyzw)</td></tr>
<tr class="memdesc:a07dd511487c9affe72695b34cd2cdbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">@overload  <a href="#a07dd511487c9affe72695b34cd2cdbf8">More...</a><br /></td></tr>
<tr class="separator:a07dd511487c9affe72695b34cd2cdbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573c1c83b42950a7c040f833236c6531"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#a573c1c83b42950a7c040f833236c6531">triangle</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i1, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i2, <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> i3)</td></tr>
<tr class="memdesc:a573c1c83b42950a7c040f833236c6531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a set of 3 vertex indices to construct a triangle; this is a shortcut to calling <a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d" title="Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list...">index()</a> 3 times.  <a href="#a573c1c83b42950a7c040f833236c6531">More...</a><br /></td></tr>
<tr class="separator:a573c1c83b42950a7c040f833236c6531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f25b71dcda784b00f2e797efa8d89a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_manual_object.html#ab6f25b71dcda784b00f2e797efa8d89a">visitRenderables</a> (<a class="el" href="class_ogre_1_1_renderable_1_1_visitor.html">Renderable::Visitor</a> *visitor, bool debugRenderables=false)</td></tr>
<tr class="memdesc:ab6f25b71dcda784b00f2e797efa8d89a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to allow a caller to abstractly iterate over the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> instances that this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will add to the render queue when asked, if any.  <a href="#ab6f25b71dcda784b00f2e797efa8d89a">More...</a><br /></td></tr>
<tr class="separator:ab6f25b71dcda784b00f2e797efa8d89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a55f1de18b85d2d276b2ea38a138b4e3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_caster.html#a55f1de18b85d2d276b2ea38a138b4e3e">clearShadowRenderableList</a> (<a class="el" href="class_ogre_1_1_shadow_caster.html#ad84ea1b2728ced5136add26c91c39a27">ShadowRenderableList</a> &amp;shadowRenderables)</td></tr>
<tr class="memdesc:a55f1de18b85d2d276b2ea38a138b4e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common implementation of releasing shadow renderables.  <a href="#a55f1de18b85d2d276b2ea38a138b4e3e">More...</a><br /></td></tr>
<tr class="separator:a55f1de18b85d2d276b2ea38a138b4e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae2215c051989d544f34083a0a9bfa2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_shadow_caster.html#acae2215c051989d544f34083a0a9bfa2">extrudeVertices</a> (const <a class="el" href="class_ogre_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;vertexBuffer, size_t originalVertexCount, const <a class="el" href="class_ogre_1_1_vector4.html">Vector4</a> &amp;lightPos, <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> extrudeDist)</td></tr>
<tr class="memdesc:acae2215c051989d544f34083a0a9bfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method for extruding vertices based on a light.  <a href="#acae2215c051989d544f34083a0a9bfa2">More...</a><br /></td></tr>
<tr class="separator:acae2215c051989d544f34083a0a9bfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f48775e48b672d7796311f3ffe2930"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a01f48775e48b672d7796311f3ffe2930">getDefaultQueryFlags</a> ()</td></tr>
<tr class="memdesc:a01f48775e48b672d7796311f3ffe2930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default query flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances.  <a href="#a01f48775e48b672d7796311f3ffe2930">More...</a><br /></td></tr>
<tr class="separator:a01f48775e48b672d7796311f3ffe2930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb94fea5944cf0d33702a75cfa14a74"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#a2eb94fea5944cf0d33702a75cfa14a74">getDefaultVisibilityFlags</a> ()</td></tr>
<tr class="memdesc:a2eb94fea5944cf0d33702a75cfa14a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default visibility flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances.  <a href="#a2eb94fea5944cf0d33702a75cfa14a74">More...</a><br /></td></tr>
<tr class="separator:a2eb94fea5944cf0d33702a75cfa14a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8db1f22329b2a96f2aed7260d565944"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ad8db1f22329b2a96f2aed7260d565944">setDefaultQueryFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:ad8db1f22329b2a96f2aed7260d565944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default query flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances.  <a href="#ad8db1f22329b2a96f2aed7260d565944">More...</a><br /></td></tr>
<tr class="separator:ad8db1f22329b2a96f2aed7260d565944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2904cb122ab8c8d5066abefb29dfa96"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_movable_object.html#ac2904cb122ab8c8d5066abefb29dfa96">setDefaultVisibilityFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:ac2904cb122ab8c8d5066abefb29dfa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default visibility flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances.  <a href="#ac2904cb122ab8c8d5066abefb29dfa96">More...</a><br /></td></tr>
<tr class="separator:ac2904cb122ab8c8d5066abefb29dfa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing a much simplified interface to generating manual objects with custom geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Building one-off geometry objects manually usually requires getting down and dirty with the vertex buffer and vertex declaration API, which some people find a steep learning curve. This class gives you a simpler interface specifically for the purpose of building a 3D object simply and quickly. Note that if you intend to instance your object you will still need to become familiar with the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> class. </dd></dl>
<dl class="section user"><dt></dt><dd>This class draws heavily on the interface for OpenGL immediate-mode (glBegin, glVertex, glNormal etc), since this is generally well-liked by people. There are a couple of differences in the results though - internally this class still builds hardware buffers which can be re-used, so you can render the resulting object multiple times without re-issuing all the same commands again. Secondly, the rendering is not immediate, it is still queued just like all OGRE objects. This makes this object more efficient than the equivalent GL immediate-mode commands, so it's feasible to use it for large objects if you really want to. </dd></dl>
<dl class="section user"><dt></dt><dd>To construct some geometry with this object:<ol type="1">
<li>If you know roughly how many vertices (and indices, if you use them) you're going to submit, call estimateVertexCount and estimateIndexCount. This is not essential but will make the process more efficient by saving memory reallocations.</li>
<li>Call <a class="el" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781" title="Start defining a part of the object. ">begin()</a> to begin entering data</li>
<li>For each vertex, call <a class="el" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0" title="Add a vertex position, starting a new vertex at the same time. ">position()</a>, <a class="el" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1" title="Add a vertex normal to the current vertex. ">normal()</a>, <a class="el" href="class_ogre_1_1_manual_object.html#a1d11e958d58e5db69e131aaad928fb80" title="Add a texture coordinate to the current vertex. ">textureCoord()</a>, <a class="el" href="class_ogre_1_1_manual_object.html#a790bf1eacf2c1c07bd663891fb6df39b" title="Add a vertex colour to a vertex. ">colour()</a> to define your vertex data. Note that each time you call <a class="el" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0" title="Add a vertex position, starting a new vertex at the same time. ">position()</a> you start a new vertex. Note that the first vertex defines the components of the vertex - you can't add more after that. For example if you didn't call <a class="el" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1" title="Add a vertex normal to the current vertex. ">normal()</a> in the first vertex, you cannot call it in any others. You ought to call the same combination of methods per vertex.</li>
<li>If you want to define triangles (or lines/points) by indexing into the vertex list, you can call <a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d" title="Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list...">index()</a> as many times as you need to define them. If you don't do this, the class will assume you want triangles drawn directly as defined by the vertex list, i.e. non-indexed geometry. Note that stencil shadows are only supported on indexed geometry, and that indexed geometry is a little faster; so you should try to use it.</li>
<li>Call <a class="el" href="class_ogre_1_1_manual_object.html#a49d6bfe460ff1e0178c6d77b95d3dc5a" title="Finish defining the object and compile the final renderable version. ">end()</a> to finish entering data.</li>
<li>Optionally repeat the begin-end cycle if you want more geometry using different rendering operation types, or different materials After calling <a class="el" href="class_ogre_1_1_manual_object.html#a49d6bfe460ff1e0178c6d77b95d3dc5a" title="Finish defining the object and compile the final renderable version. ">end()</a>, the class will organise the data for that section internally and make it ready to render with. Like any other <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> you should attach the object to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> to make it visible. Other aspects like the relative render order can be controlled using standard <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> methods like setRenderQueueGroup. </li>
</ol>
</dd></dl>
<dl class="section user"><dt></dt><dd>You can also use <a class="el" href="class_ogre_1_1_manual_object.html#a0c4103359ee463b1a000623d9516291c" title="Start the definition of an update to a part of the object. ">beginUpdate()</a> to alter the geometry later on if you wish. If you do this, you should call setDynamic(true) before your first call to <a class="el" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781" title="Start defining a part of the object. ">begin()</a>, and also consider using estimateVertexCount / estimateIndexCount if your geometry is going to be growing, to avoid buffer recreation during growth. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that like all OGRE geometry, triangles should be specified in anti-clockwise winding order (whether you're doing it with just vertices, or using indexes too). That is to say that the front of the face is the one where the vertices are listed in anti-clockwise order. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aed2302f68cdadd3f043d503eeeccd928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a>*&gt;::type <a class="el" href="class_ogre_1_1_manual_object.html#aed2302f68cdadd3f043d503eeeccd928">Ogre::ManualObject::SectionList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad84ea1b2728ced5136add26c91c39a27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="class_ogre_1_1_shadow_renderable.html">ShadowRenderable</a>*&gt;::type <a class="el" href="class_ogre_1_1_shadow_caster.html#ad84ea1b2728ced5136add26c91c39a27">Ogre::ShadowCaster::ShadowRenderableList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b0999d33e25db97d0449d6cf95cbecd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_vector_iterator.html">VectorIterator</a>&lt;<a class="el" href="class_ogre_1_1_shadow_caster.html#ad84ea1b2728ced5136add26c91c39a27">ShadowRenderableList</a>&gt; <a class="el" href="class_ogre_1_1_shadow_caster.html#a7b0999d33e25db97d0449d6cf95cbecd">Ogre::ShadowCaster::ShadowRenderableListIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a88d99ad5d5fdb5702f7a6b8c3fdd82af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::ManualObject::ManualObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a021bc790af45aaa6ce7f7505ea98ccd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::ManualObject::~ManualObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a748269201d1e2df008b7b1c37590ab24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::_releaseManualHardwareResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the movable object that hardware resources were lost. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Called automatically by <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> if hardware resources were lost and can not be restored using some internal mechanism. Among affected resources are nested shadow renderables, ManualObjects, etc. </dd></dl>

<p>Reimplemented from <a class="el" href="class_ogre_1_1_movable_object.html#a57123ae4fec1b472f25270c1dd6abe59">Ogre::MovableObject</a>.</p>

<p>References <a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>, and <a class="el" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10da8c00ee152b44fe8000c2fd675437c087">Ogre::RenderOperation::OT_TRIANGLE_LIST</a>.</p>

</div>
</div>
<a class="anchor" id="acd3a1d7a06fbf52829708b270a1f6dc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Completely clear the contents of the object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Clearing the contents of this object and rebuilding from scratch is not the optimal way to manage dynamic vertex data, since the buffers are recreated. If you want to keep the same structure but update the content within that structure, use <a class="el" href="class_ogre_1_1_manual_object.html#a0c4103359ee463b1a000623d9516291c" title="Start the definition of an update to a part of the object. ">beginUpdate()</a> instead of <a class="el" href="class_ogre_1_1_manual_object.html#acd3a1d7a06fbf52829708b270a1f6dc8" title="Completely clear the contents of the object. ">clear()</a> <a class="el" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781" title="Start defining a part of the object. ">begin()</a>. However if you do want to modify the structure from time to time you can do so by clearing and re-specifying the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a9448c472c45235366231ec1a6e4e5b73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::estimateVertexCount </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vcount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the number of vertices ahead of time. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Calling this helps to avoid memory reallocation when you define vertices. Also very handy when using <a class="el" href="class_ogre_1_1_manual_object.html#a0c4103359ee463b1a000623d9516291c" title="Start the definition of an update to a part of the object. ">beginUpdate()</a> to manage dynamic data - you can make the vertex buffers a little larger than their initial needs to allow for growth later with this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a59153e5ecd0f694c9ef143ad57ae082f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::estimateIndexCount </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>icount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate the number of indices ahead of time. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Calling this helps to avoid memory reallocation when you define indices. Also very handy when using <a class="el" href="class_ogre_1_1_manual_object.html#a0c4103359ee463b1a000623d9516291c" title="Start the definition of an update to a part of the object. ">beginUpdate()</a> to manage dynamic data - you can make the index buffer a little larger than the initial need to allow for growth later with this method. </dd></dl>

</div>
</div>
<a class="anchor" id="a70d5945478fbc7fa056cecd88fdf2781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>materialName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10d">RenderOperation::OperationType</a>&#160;</td>
          <td class="paramname"><em>opType</em> = <code><a class="el" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10da8c00ee152b44fe8000c2fd675437c087">RenderOperation::OT_TRIANGLE_LIST</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start defining a part of the object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Each time you call this method, you start a new section of the object with its own material and potentially its own type of rendering operation (triangles, points or lines for example). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">materialName</td><td>The name of the material to render this part of the object with. </td></tr>
    <tr><td class="paramname">opType</td><td>The type of operation to use to render. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83143f157514a3bb44e325df19fdefde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::setDynamic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dyn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use before defining geometry to indicate that you intend to update the geometry regularly and want the internal structure to reflect that. </p>

</div>
</div>
<a class="anchor" id="a1404661a0e201ad6171cd0d35c036297"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::ManualObject::getDynamic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether this object is marked as dynamic. </p>

<p>References <a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a>.</p>

</div>
</div>
<a class="anchor" id="a0c4103359ee463b1a000623d9516291c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::beginUpdate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sectionIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the definition of an update to a part of the object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Using this method, you can update an existing section of the object efficiently. You do not have the option of changing the operation type obviously, since it must match the one that was used before. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If your sections are changing size, particularly growing, use estimateVertexCount and estimateIndexCount to pre-size the buffers a little larger than the initial needs to avoid buffer reconstruction. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sectionIndex</td><td>The index of the section you want to update. The first call to <a class="el" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781" title="Start defining a part of the object. ">begin()</a> would have created section 0, the second section 1, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9986bd2627b75deeba14636c81efcde0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex position, starting a new vertex at the same time. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A vertex position is slightly special among the other vertex data methods like <a class="el" href="class_ogre_1_1_manual_object.html#a59c0b0a41e2a4ced5ff89589c9a924a1" title="Add a vertex normal to the current vertex. ">normal()</a> and <a class="el" href="class_ogre_1_1_manual_object.html#a1d11e958d58e5db69e131aaad928fb80" title="Add a texture coordinate to the current vertex. ">textureCoord()</a>, since calling it indicates the start of a new vertex. All other vertex data methods you call after this are assumed to be adding more information (like normals or texture coordinates) to the last vertex started with <a class="el" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0" title="Add a vertex position, starting a new vertex at the same time. ">position()</a>. </dd></dl>

<p>Referenced by <a class="el" href="class_ogre_1_1_volume_1_1_mesh_builder.html#ae3a953ca0ebafa9df031af1afe2c8b15">Ogre::Volume::MeshBuilder::addCubeToManualObject()</a>.</p>

</div>
</div>
<a class="anchor" id="a57455f9489a4afb834de1832f04bfc31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a59c0b0a41e2a4ced5ff89589c9a924a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex normal to the current vertex. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Vertex normals are most often used for dynamic lighting, and their components should be normalised. </dd></dl>

</div>
</div>
<a class="anchor" id="a3960a89127a745b20310f00cb8526549"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a523bf713b8f94d325222d673f2be9518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::tangent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>tan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex tangent to the current vertex. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Vertex tangents are most often used for dynamic lighting, and their components should be normalised. Also, using <a class="el" href="class_ogre_1_1_manual_object.html#a523bf713b8f94d325222d673f2be9518" title="Add a vertex tangent to the current vertex. ">tangent()</a> you enable VES_TANGENT vertex semantic, which is not supported on old non-SM2 cards. </dd></dl>

</div>
</div>
<a class="anchor" id="a8365a3dc159928c14824aa65b17585c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::tangent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a1d11e958d58e5db69e131aaad928fb80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a texture coordinate to the current vertex. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can call this method multiple times between <a class="el" href="class_ogre_1_1_manual_object.html#a9986bd2627b75deeba14636c81efcde0" title="Add a vertex position, starting a new vertex at the same time. ">position()</a> calls to add multiple texture coordinates to a vertex. Each one can have between 1 and 3 dimensions, depending on your needs, although 2 is most common. There are several versions of this method for the variations in number of dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9e9cf451570dbf5f5f3ff0c7bd2962a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a896e08b7414ed011e6804d22478fb010"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a7cc068c843bb3d5c535ad2f2b936fcf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ab57231f12ab74f84e902f0b807018a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector2.html">Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>uv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="ada31136462c099a7d766a42b3e246050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>uvw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a07dd511487c9affe72695b34cd2cdbf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::textureCoord </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>xyzw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>@overload </p>

</div>
</div>
<a class="anchor" id="a790bf1eacf2c1c07bd663891fb6df39b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::colour </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_colour_value.html">ColourValue</a> &amp;&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex colour to a vertex. </p>

</div>
</div>
<a class="anchor" id="a7c07cde8a219635535b34622f7f22420"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::colour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>a</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="acadcdf04053511d97e7e29848c6eef3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list of vertices. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You will have to call this 3 times for each face for a triangle list, or use the alternative 3-parameter version. Other operation types require different numbers of indexes, </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_render_operation.html#a7a272218dae54048c87f31176c19e10d" title="The rendering operation type to perform. ">RenderOperation::OperationType</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>32-bit indexes are not supported on all cards and will only be used when required, if an index is &gt; 65535. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>A vertex index from 0 to 4294967295. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="class_ogre_1_1_volume_1_1_mesh_builder.html#ae3a953ca0ebafa9df031af1afe2c8b15">Ogre::Volume::MeshBuilder::addCubeToManualObject()</a>.</p>

</div>
</div>
<a class="anchor" id="a573c1c83b42950a7c040f833236c6531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a set of 3 vertex indices to construct a triangle; this is a shortcut to calling <a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d" title="Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list...">index()</a> 3 times. </p>
<p>It is only valid for triangle lists. </p><dl class="section note"><dt>Note</dt><dd>32-bit indexes are not supported on all cards and will only be used when required, if an index is &gt; 65535. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1,i2,i3</td><td>3 vertex indices from 0 to 4294967295 defining a face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ac70dbc6f35180d5c8bab671c3f2257"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>i4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a set of 4 vertex indices to construct a quad (out of 2 triangles); this is a shortcut to calling <a class="el" href="class_ogre_1_1_manual_object.html#acadcdf04053511d97e7e29848c6eef3d" title="Add a vertex index to construct faces / lines / points via indexing rather than just by a simple list...">index()</a> 6 times, or <a class="el" href="class_ogre_1_1_manual_object.html#a573c1c83b42950a7c040f833236c6531" title="Add a set of 3 vertex indices to construct a triangle; this is a shortcut to calling index() 3 times...">triangle()</a> twice. </p>
<p>It's only valid for triangle list operations. </p><dl class="section note"><dt>Note</dt><dd>32-bit indexes are not supported on all cards and will only be used when required, if an index is &gt; 65535. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i1,i2,i3,i4</td><td>4 vertex indices from 0 to 4294967295 defining a quad. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6155692f6b3873234c2f5a20e18c643"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::ManualObject::getCurrentVertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertices in the section currently being defined (returns 0 if no section is in progress). </p>

</div>
</div>
<a class="anchor" id="a237bbc1d4e569e58ab971384be37fc42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Ogre::ManualObject::getCurrentIndexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of indices in the section currently being defined (returns 0 if no section is in progress). </p>

</div>
</div>
<a class="anchor" id="a49d6bfe460ff1e0178c6d77b95d3dc5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a>* Ogre::ManualObject::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish defining the object and compile the final renderable version. </p>
<dl class="section note"><dt>Note</dt><dd>Will return a pointer to the finished section or NULL if the section was discarded (i.e. has zero vertices/indices). </dd></dl>

</div>
</div>
<a class="anchor" id="ad67a3cc60f094ea252621023f084887b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::ManualObject::setMaterialName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alter the material for a subsection of this object after it has been specified. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You specify the material to use on a section of this object during the call to <a class="el" href="class_ogre_1_1_manual_object.html#a70d5945478fbc7fa056cecd88fdf2781" title="Start defining a part of the object. ">begin()</a>, however if you want to change the material afterwards you can do so by calling this method. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subIndex</td><td>The index of the subsection to alter </td></tr>
    <tr><td class="paramname">name</td><td>The name of the new material to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a657275e617d9558951a3037f02b07efe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#a5c4c0c56ea9f824c49e331f6fad33ddb">MeshPtr</a> Ogre::ManualObject::convertToMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>groupName</em> = <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a3c7d7dc6bb59e43db49e77cd3d8a44c4">ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert this object to a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>After you've finished building this object, you may convert it to a <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> if you want in order to be able to create many instances of it in the world (via <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a>). This is optional, since this instance can be directly attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> itself, but of course only one instance of it can exist that way. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only objects which use indexed geometry may be converted to a mesh. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshName</td><td>The name to give the mesh </td></tr>
    <tr><td class="paramname">groupName</td><td>The resource group to create the mesh in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f832d5605c489db7be396ec7cd20b85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::setUseIdentityProjection </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useIdentityProjection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not to use an 'identity' projection. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Usually ManualObjects will use a projection matrix as determined by the active camera. However, if they want they can cancel this out and use an identity projection, which effectively projects in 2D using a {-1, 1} view space. Useful for overlay rendering. Normally you don't need to change this. The default is false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_manual_object.html#a54b0416a4bde818687699da8c73d51f1" title="Returns whether or not to use an &#39;identity&#39; projection. ">ManualObject::getUseIdentityProjection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54b0416a4bde818687699da8c73d51f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ManualObject::getUseIdentityProjection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not to use an 'identity' projection. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Usually ManualObjects will use a projection matrix as determined by the active camera. However, if they want they can cancel this out and use an identity projection, which effectively projects in 2D using a {-1, 1} view space. Useful for overlay rendering. Normally you don't need to change this. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_manual_object.html#a7f832d5605c489db7be396ec7cd20b85" title="Sets whether or not to use an &#39;identity&#39; projection. ">ManualObject::setUseIdentityProjection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b01abfbb1b9ef4c6d9e747d6474116c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::setUseIdentityView </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useIdentityView</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether or not to use an 'identity' view. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Usually ManualObjects will use a view matrix as determined by the active camera. However, if they want they can cancel this out and use an identity matrix, which means all geometry is assumed to be relative to camera space already. Useful for overlay rendering. Normally you don't need to change this. The default is false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_manual_object.html#a79071ea0007acab8f18cb4c6ffc6eaf9" title="Returns whether or not to use an &#39;identity&#39; view. ">ManualObject::getUseIdentityView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a79071ea0007acab8f18cb4c6ffc6eaf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ManualObject::getUseIdentityView </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not to use an 'identity' view. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Usually ManualObjects will use a view matrix as determined by the active camera. However, if they want they can cancel this out and use an identity matrix, which means all geometry is assumed to be relative to camera space already. Useful for overlay rendering. Normally you don't need to change this. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_manual_object.html#a6b01abfbb1b9ef4c6d9e747d6474116c" title="Sets whether or not to use an &#39;identity&#39; view. ">ManualObject::setUseIdentityView</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44a840aa95ae13acb026db417b86b4f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::setBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the bounding box. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Call this after having finished creating sections to modify the bounding box. E.g. if you're using <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">ManualObject</a> to create 2D overlays you can call things function to set an infinite bounding box so that the object always stays visible when attached. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_manual_object.html#a7f832d5605c489db7be396ec7cd20b85" title="Sets whether or not to use an &#39;identity&#39; projection. ">ManualObject::setUseIdentityProjection</a>, <a class="el" href="class_ogre_1_1_manual_object.html#a6b01abfbb1b9ef4c6d9e747d6474116c" title="Sets whether or not to use an &#39;identity&#39; view. ">ManualObject::setUseIdentityView</a>, <a class="el" href="class_ogre_1_1_axis_aligned_box.html#a1d02be8fab444a465b52795175fe52dc" title="Sets the box to &#39;infinite&#39;. ">AxisAlignedBox::setInfinite</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a583626e6d061aa7751dd9c840c9067cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html">ManualObjectSection</a>* Ogre::ManualObject::getSection </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a pointer to a <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html" title="Built, renderable section of geometry. ">ManualObjectSection</a>, i.e. </p>
<p>a part of a <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">ManualObject</a>. </p>

</div>
</div>
<a class="anchor" id="ad97ea7aa7bc3368eeef26e35faaf5f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Ogre::ManualObject::getNumSections </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of <a class="el" href="class_ogre_1_1_manual_object_1_1_manual_object_section.html" title="Built, renderable section of geometry. ">ManualObjectSection</a> objects making up this <a class="el" href="class_ogre_1_1_manual_object.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">ManualObject</a>. </p>

</div>
</div>
<a class="anchor" id="aaf0b959647ec405c9e2b95c86a674378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::setKeepDeclarationOrder </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepOrder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not to keep the original declaration order when queuing the renderables. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This overrides the default behavior of the rendering queue, specifically stating the desired order of rendering. Might result in a performance loss, but lets the user to have more direct control when creating geometry through this class. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keepOrder</td><td>Whether to keep the declaration order or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9b516742f7f117b8e8a2eec7187adc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ManualObject::getKeepDeclarationOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether or not the declaration order is to be kept or not. </p>
<dl class="section return"><dt>Returns</dt><dd>A flag indication if the declaration order will be kept when queuing the renderables. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd2accb4a7bfbe56028b2a380cbf371"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::ManualObject::getMovableType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type name of this object. </p>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#a7391beac8beb20e3e3d650173d33a3ff">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="ad6e0402c8f0729b259e8370ea4188cbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::ManualObject::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the local axis-aligned bounding box for this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This bounding box is in local coordinates. </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#a4bb24d3bee90b0c9e15fd65702030fa4">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="ab7af7e372a27337225bcac207ea81c9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::ManualObject::getBoundingRadius </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the radius of the origin-centered bounding sphere for this object. </p>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#aed6d3f3856d030a967eb17d78a598807">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="aeb2201138dbe5b3966a7704aaebbe7fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::_updateRenderQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_render_queue.html">RenderQueue</a> *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method by which the movable object must add <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> subclass instances to the rendering queue. </p>
<dl class="section remark"><dt>Remarks</dt><dd>The engine will call this method when this object is to be rendered. The object must then create one or more <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> subclass instances which it places on the passed in Queue for rendering. </dd></dl>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#ac77b03ec95bbe3de7d9b9d7993dc785e">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="a5a53798ccf0c34105122ee77dad0904d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_edge_data.html">EdgeData</a>* Ogre::ManualObject::getEdgeList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to enable stencil shadows. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#a9ec42d43470c2e2b0f6f05221371a786">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="a77b98b65fbf51b3b611b4e423c74fe79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::ManualObject::hasEdgeList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden member from <a class="el" href="class_ogre_1_1_shadow_caster.html" title="This class defines the interface that must be implemented by shadow casters. ">ShadowCaster</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#a99cc616f547693f39fa354e6600368e6">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="a87917ee5f2096373753098bfc2e179cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_shadow_caster.html#a7b0999d33e25db97d0449d6cf95cbecd">ShadowRenderableListIterator</a> Ogre::ManualObject::getShadowVolumeRenderableIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6">ShadowTechnique</a>&#160;</td>
          <td class="paramname"><em>shadowTechnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_hardware_index_buffer_shared_ptr.html">HardwareIndexBufferSharedPtr</a> *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>indexBufferUsedSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extrudeVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>extrusionDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement this method to enable stencil shadows. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#afaf1dfad22f842b9b2cb2a0beaad98eb">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="ab6f25b71dcda784b00f2e797efa8d89a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::ManualObject::visitRenderables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable_1_1_visitor.html">Renderable::Visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debugRenderables</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to allow a caller to abstractly iterate over the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> instances that this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will add to the render queue when asked, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Pointer to a class implementing the <a class="el" href="class_ogre_1_1_renderable_1_1_visitor.html" title="Visitor object that can be used to iterate over a collection of Renderable instances abstractly...">Renderable::Visitor</a> interface which will be called back for each <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> which will be queued. Bear in mind that the state of the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> instances may not be finalised depending on when you call this. </td></tr>
    <tr><td class="paramname">debugRenderables</td><td>If false, only regular renderables will be visited (those for normal display). If true, debug renderables will be included too. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_ogre_1_1_movable_object.html#a572b6aaa7a8b412163184a6c68ca3fa0">Ogre::MovableObject</a>.</p>

</div>
</div>
<a class="anchor" id="a06f161ae0451be7eaa67e77c296d5631"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::_notifyCreator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object_factory.html">MovableObjectFactory</a> *&#160;</td>
          <td class="paramname"><em>fact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the object of it's creator (internal use only) </p>

</div>
</div>
<a class="anchor" id="a01cbeec62e231ef06f3527dd46d032f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_movable_object_factory.html">MovableObjectFactory</a>* Ogre::MovableObject::_getCreator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the creator of this object, if any (internal use only) </p>

</div>
</div>
<a class="anchor" id="af730ac3ee4a51ee69f4221298f933e8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::_notifyManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>man</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notify the object of it's manager (internal use only) </p>

</div>
</div>
<a class="anchor" id="ac45888252f96cda04df97f1f6f98f45b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a>* Ogre::MovableObject::_getManager </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the manager of this object, if any (internal use only) </p>

</div>
</div>
<a class="anchor" id="abd5561a07f78291e327351fe83e64a9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::_restoreManualHardwareResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the movable object that hardware resources should be restored. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Called automatically by <a class="el" href="class_ogre_1_1_render_system.html" title="Defines the functionality of a 3D API. ">RenderSystem</a> if hardware resources were lost and can not be restored using some internal mechanism. Among affected resources are nested shadow renderables, ManualObjects, etc. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html#a603840708bb387c13da8ca5ac7c98808">Ogre::StaticGeometry::Region</a>, and <a class="el" href="class_ogre_1_1_entity.html#a81bc0afcbba4cd5978fe8c648798c1da">Ogre::Entity</a>.</p>

</div>
</div>
<a class="anchor" id="a24af8a9f885f5dd12dbb00407e30050e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::MovableObject::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this object. </p>

</div>
</div>
<a class="anchor" id="a96b5ce572f51a41e31d72edd0c6fcf6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_node.html">Node</a>* Ogre::MovableObject::getParentNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node to which this object is attached. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> may be attached to either a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or to a <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>, the latter case if it's attached to a bone on an animated entity. Both are <a class="el" href="class_ogre_1_1_node.html" title="Class representing a general-purpose node an articulated scene graph. ">Node</a> subclasses so this method will return either. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8f09f421fc7f9827844f6bb138360f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a>* Ogre::MovableObject::getParentSceneNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the scene node to which this object is attached. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> may be attached to either a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or to a <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>, the latter case if it's attached to a bone on an animated entity. This method will return the scene node of the parent entity if the latter is true. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fe660d572f96913e2e3434440a342f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::MovableObject::isParentTagPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether the parent node is a <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a> (or a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>) </p>

</div>
</div>
<a class="anchor" id="aeb13418fe2740ed8ebc52cd9667fca41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::_notifyAttached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isTagPoint</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method called to notify the object that it has been attached to a node. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_entity.html#aa00c4d0ae6c87888b0188bb7356d99dc">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_particle_system.html#a2937e606da2beda93f8b65695de90d0b">Ogre::ParticleSystem</a>, <a class="el" href="class_ogre_1_1_light.html#a2c4dddb1da9079b9f68236c86a689e54">Ogre::Light</a>, <a class="el" href="class_ogre_1_1_portal_base.html#ad2cfb28e1ef786ed83ea88ac22675837">Ogre::PortalBase</a>, and <a class="el" href="group___scene.html#ga0faadbd22a01ef1b959e0c63598bc79a">Ogre::InstancedEntity</a>.</p>

<p>Referenced by <a class="el" href="class_ogre_1_1_portal_base.html#ad2cfb28e1ef786ed83ea88ac22675837">Ogre::PortalBase::_notifyAttached()</a>.</p>

</div>
</div>
<a class="anchor" id="af40bba3d61d14e27a9cc86ac93c007df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::MovableObject::isAttached </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this object is attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>. </p>

</div>
</div>
<a class="anchor" id="a61b39d44e60020d43033a6957895aa5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::detachFromParent </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detaches an object from a parent <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>, if attached. </p>

</div>
</div>
<a class="anchor" id="a605cb18ec6d5971e19491ec71c89afeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::MovableObject::isInScene </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this object is attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> or <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a>, and this <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> / <a class="el" href="class_ogre_1_1_tag_point.html" title="A tagged point on a skeleton, which can be used to attach entities to on specific other entities...">TagPoint</a> is currently in an active part of the scene graph. </p>

<p>Reimplemented in <a class="el" href="group___scene.html#ga68d632a2efac0e4ab0567cee3852871a">Ogre::InstancedEntity</a>.</p>

</div>
</div>
<a class="anchor" id="ae307c64b6e130191e45d48df0e2c5961"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::_notifyMoved </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method called to notify the object that it has been moved. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_light.html#acc93817276a3ea236bb45a19de4f5d4e">Ogre::Light</a>, <a class="el" href="class_ogre_1_1_portal_base.html#a771d99cc1f7b16d289a9d023d8a60aa7">Ogre::PortalBase</a>, <a class="el" href="group___scene.html#gac18e33cc9b2824de974cd4259874ac62">Ogre::InstancedEntity</a>, and <a class="el" href="class_ogre_1_1_p_c_z_light.html#a6944ad4ba92212a50c7350dc7ecb06e9">Ogre::PCZLight</a>.</p>

</div>
</div>
<a class="anchor" id="aa805908a2945ba1e1b1d6badb4761e27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::_notifyCurrentCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_camera.html">Camera</a> *&#160;</td>
          <td class="paramname"><em>cam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method to notify the object of the camera to be used for the next rendering operation. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Certain objects may want to do specific processing based on the camera position. This method notifies them in case they wish to do this. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_billboard_set.html#a2b90d3f4d3cce651644763743e0538ea">Ogre::BillboardSet</a>, <a class="el" href="class_ogre_1_1_instanced_geometry_1_1_batch_instance.html#abeed8b66fa573243dab6234935cf20c3">Ogre::InstancedGeometry::BatchInstance</a>, <a class="el" href="class_ogre_1_1_frustum.html#acc9600b98b04f28b28b3a05c1c352829">Ogre::Frustum</a>, <a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html#aac53e78f006299fdd935c4d29ca713fa">Ogre::StaticGeometry::Region</a>, <a class="el" href="class_ogre_1_1_entity.html#a7eb4f29cfb41d91de47ff92c9c011f60">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_particle_system.html#a2a51ddf360d8c36cab0e3b636757af5c">Ogre::ParticleSystem</a>, <a class="el" href="group___scene.html#gaeb967751f31d275489389e9988f1aac2">Ogre::InstanceBatch</a>, <a class="el" href="class_ogre_1_1_simple_renderable.html#a47d8e69386caeba126d0eaa97410bd28">Ogre::SimpleRenderable</a>, and <a class="el" href="class_ogre_1_1_movable_plane.html#a6d0680e3e68f81a9498c30d5257d4293">Ogre::MovablePlane</a>.</p>

</div>
</div>
<a class="anchor" id="acc31c877990c3c231c4b4cfb0522bef8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::MovableObject::getWorldBoundingBox </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>derive</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the axis-aligned bounding box for this object in world coordinates. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#a6ab7144efe1ca481a4a9a89365ed522d">Ogre::ShadowCaster</a>.</p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_entity.html#a5edde0278ae3942c9816690cb3462853">Ogre::Entity</a>, and <a class="el" href="class_ogre_1_1_portal_base.html#a9a031b66af992dd0163aacd67b6bf4fd">Ogre::PortalBase</a>.</p>

</div>
</div>
<a class="anchor" id="a2f6db9f0db4038e6544d703a9f3bcf53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_sphere.html">Sphere</a>&amp; Ogre::MovableObject::getWorldBoundingSphere </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>derive</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the worldspace bounding sphere for this object. </p>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_entity.html#a08900679175af3be2cf039cada86ec85">Ogre::Entity</a>, and <a class="el" href="class_ogre_1_1_portal_base.html#afe9d0bb945b40f0356fe6517f3eae8af">Ogre::PortalBase</a>.</p>

</div>
</div>
<a class="anchor" id="ad563191e86e4d119c62ea9acfc2a90d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells this object whether to be visible or not, if it has a renderable component. </p>
<dl class="section note"><dt>Note</dt><dd>An alternative approach of making an object invisible is to detach it from it's <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a>, or to remove the <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> entirely. Detaching a node means that structurally the scene graph changes. Once this change has taken place, the objects / nodes that have been removed have less overhead to the visibility detection pass than simply making the object invisible, so if you do this and leave the objects out of the tree for a long time, it's faster. However, the act of detaching / reattaching nodes is in itself more expensive than setting an object visibility flag, since in the latter case structural changes are not made. Therefore, small or frequent visibility changes are best done using this method; large or more longer term changes are best done by detaching. </dd></dl>

<p>Referenced by <a class="el" href="class_ogre_1_1_light.html#a264a43fc2cf02093736eae60316dda8e">Ogre::Light::setVisible()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cc231df154e2a639cfe42df49947c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::MovableObject::getVisible </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets this object whether to be visible or not, if it has a renderable component. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Returns the value set by <a class="el" href="class_ogre_1_1_movable_object.html#ad563191e86e4d119c62ea9acfc2a90d5" title="Tells this object whether to be visible or not, if it has a renderable component. ...">MovableObject::setVisible</a> only. </dd></dl>

</div>
</div>
<a class="anchor" id="aebb41fb7484f365c18e78103517b0d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::MovableObject::isVisible </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this object is supposed to be visible or not. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Takes into account both upper rendering distance and visible flag. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_instanced_geometry_1_1_batch_instance.html#ad7c128818584b173b0c6f97ee3a655a6">Ogre::InstancedGeometry::BatchInstance</a>, and <a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html#a84fb2cc526633ef8c7955d19b2fe8dc9">Ogre::StaticGeometry::Region</a>.</p>

<p>Referenced by <a class="el" href="class_ogre_1_1_frustum.html#a16e00143dd34480120aeb370f222551a">Ogre::Frustum::isCustomProjectionMatrixEnabled()</a>.</p>

</div>
</div>
<a class="anchor" id="afe1f2a1009e3f14f36e1bcc9b1b9557e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setRenderingDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the distance at which the object is no longer rendered. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_ogre_1_1_camera.html#af0f02c8ac7e6dc46ae6cd8ee209abd8e" title="Set whether this camera should use the &#39;rendering distance&#39; on objects to exclude distant objects fro...">Camera::setUseRenderingDistance()</a> needs to be called for this parameter to be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>Distance beyond which the object will not be rendered (the default is 0, which means objects are always rendered). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf66828e73b2248f723574b9096398d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::MovableObject::getRenderingDistance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the distance at which batches are no longer rendered. </p>

</div>
</div>
<a class="anchor" id="a4d43f57e9abcc21d4bc50e6e6d1b5cc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setRenderingMinPixelSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>pixelSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the minimum pixel size an object needs to be in both screen axes in order to be rendered. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_ogre_1_1_camera.html#a62d47145eb99e07af3de0915645be07c" title="Sets whether to use min display size calculations. ">Camera::setUseMinPixelSize()</a> needs to be called for this parameter to be used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixelSize</td><td>Number of minimum pixels (the default is 0, which means objects are always rendered). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01b928de7466910e0cc8513c15fd492c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::MovableObject::getRenderingMinPixelSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum pixel size an object needs to be in both screen axes in order to be rendered. </p>

</div>
</div>
<a class="anchor" id="a1ad93e3514b969971213ff4ae80103dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setUserAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_any.html">Any</a> &amp;&#160;</td>
          <td class="paramname"><em>anything</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a> via <a class="el" href="class_ogre_1_1_movable_object.html#aaac5bf65835f733433f3338132f2f01f" title="Return an instance of user objects binding associated with this class. ">getUserObjectBindings()</a> instead.</dd></dl>
<p>Sets any kind of user value on this object. </p><dl class="section remark"><dt>Remarks</dt><dd>This method allows you to associate any user value you like with this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>. This can be a pointer back to one of your own classes for instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9e745d2a09637903b91912419e00a52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_any.html">Any</a>&amp; Ogre::MovableObject::getUserAny </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000064">Deprecated:</a></b></dt><dd>use <a class="el" href="class_ogre_1_1_user_object_bindings.html#a9c4b12b7ceeddd3a6f28dae1ac8d09a2" title="Retrieves the custom key less user object associated with this class. ">UserObjectBindings::getUserAny</a> via <a class="el" href="class_ogre_1_1_movable_object.html#aaac5bf65835f733433f3338132f2f01f" title="Return an instance of user objects binding associated with this class. ">getUserObjectBindings()</a> instead.</dd></dl>
<p>Retrieves the custom user value associated with this object. </p>

</div>
</div>
<a class="anchor" id="aaac5bf65835f733433f3338132f2f01f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::MovableObject::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abbf5cf5545c219ce9be1997ff5dd2204"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_user_object_bindings.html">UserObjectBindings</a>&amp; Ogre::MovableObject::getUserObjectBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an instance of user objects binding associated with this class. </p>
<p>You can use it to associate one or more custom objects with this class instance. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_user_object_bindings.html#ac6d05bbca44c5c3b44860c36205f9a68" title="Sets any kind of user object on this class instance. ">UserObjectBindings::setUserAny</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e898937867475e52d350d1f4d75e32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::setRenderQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>queueID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the render queue group this entity will be rendered through. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Render queues are grouped to allow you to more tightly control the ordering of rendered objects. If you do not call this method, all <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> objects default to the default queue (<a class="el" href="class_ogre_1_1_render_queue.html#ab263254bd0c13a91c44d5fafd18c16c3" title="Gets the current default queue group, which will be used for all renderable which do not specify whic...">RenderQueue::getDefaultQueueGroup</a>), which is fine for most objects. You may want to alter this if you want this entity to always appear in front of other objects, e.g. for a 3D menu system or such. </dd></dl>
<dl class="section user"><dt></dt><dd>See <a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue. ">RenderQueue</a> for more details. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueID</td><td>Enumerated value of the queue group to use. See the enum RenderQueueGroupID for what kind of values can be used here. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_particle_system.html#a6c8e8e0329e0924b6b0a4b5174448a11">Ogre::ParticleSystem</a>, and <a class="el" href="class_ogre_1_1_entity.html#a779d9a0bb037f2dd42493329bf5ff805">Ogre::Entity</a>.</p>

</div>
</div>
<a class="anchor" id="a38cf564fe839d40a81ba5155d363b7aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::MovableObject::setRenderQueueGroupAndPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>queueID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#af851e71354d841df7138f9877c6f5931">ushort</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the render queue group and group priority this entity will be rendered through. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Render queues are grouped to allow you to more tightly control the ordering of rendered objects. Within a single render group there another type of grouping called priority which allows further control. If you do not call this method, all <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> objects default to the default queue and priority (<a class="el" href="class_ogre_1_1_render_queue.html#ab263254bd0c13a91c44d5fafd18c16c3" title="Gets the current default queue group, which will be used for all renderable which do not specify whic...">RenderQueue::getDefaultQueueGroup</a>, <a class="el" href="class_ogre_1_1_render_queue.html#a3903367113d6a51591ad16faeb17e8e0" title="Gets the current default renderable priority, which will be used for all renderables which do not spe...">RenderQueue::getDefaultRenderablePriority</a>), which is fine for most objects. You may want to alter this if you want this entity to always appear in front of other objects, e.g. for a 3D menu system or such. </dd></dl>
<dl class="section user"><dt></dt><dd>See <a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue. ">RenderQueue</a> for more details. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueID</td><td>Enumerated value of the queue group to use. See the enum RenderQueueGroupID for what kind of values can be used here. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority within a group to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_particle_system.html#a71c9421a0a505482994c90e024b9d349">Ogre::ParticleSystem</a>, and <a class="el" href="class_ogre_1_1_entity.html#a2fc9c3b61a21faed96036bdb8a8f9948">Ogre::Entity</a>.</p>

</div>
</div>
<a class="anchor" id="abab84842614331bde8bdd3e756456698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::MovableObject::getRenderQueueGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the queue group for this entity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_movable_object.html#ac5e898937867475e52d350d1f4d75e32" title="Sets the render queue group this entity will be rendered through. ">setRenderQueueGroup</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab6d217065c5d2968ef0cc2586a0db86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_matrix4.html">Matrix4</a>&amp; Ogre::MovableObject::_getParentNodeFullTransform </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full transformation of the parent sceneNode or the attachingPoint node. </p>

<p>Reimplemented in <a class="el" href="group___scene.html#gaaa3bfaf1f283e98391ac1b55fb2bd9b6">Ogre::InstancedEntity</a>.</p>

</div>
</div>
<a class="anchor" id="a77198e02dd65dd368ea4e6af88a93fda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setQueryFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the query flags for this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>When performing a scene query, this object will be included or excluded according to flags on the object and flags on the query. This is a bitwise value, so only when a bit on these flags is set, will it be included in a query asking for that flag. The meaning of the bits is application-specific. </dd></dl>

</div>
</div>
<a class="anchor" id="a98fe88f82f86eafa19308074495db809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::addQueryFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As setQueryFlags, except the flags passed as parameters are appended to the existing flags on this object. </p>

</div>
</div>
<a class="anchor" id="a6fb94e1627676c7d7517e13944bd0580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::removeQueryFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As setQueryFlags, except the flags passed as parameters are removed from the existing flags on this object. </p>

</div>
</div>
<a class="anchor" id="a365e39e9322a3c96030148b3bae233de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::MovableObject::getQueryFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the query flags relevant for this object. </p>

</div>
</div>
<a class="anchor" id="ad8db1f22329b2a96f2aed7260d565944"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::MovableObject::setDefaultQueryFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default query flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances. </p>

</div>
</div>
<a class="anchor" id="a01f48775e48b672d7796311f3ffe2930"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::MovableObject::getDefaultQueryFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default query flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances. </p>

</div>
</div>
<a class="anchor" id="a28b12f8d0fd7c9da7fcd1e9806dd8064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setVisibilityFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the visibility flags for this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>As well as a simple true/false value for visibility (as seen in setVisible), you can also set visibility flags which when 'and'ed with the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a>'s visibility mask can also make an object invisible. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b823b52684730302908ecfd1a8e6d54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::addVisibilityFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As setVisibilityFlags, except the flags passed as parameters are appended to the existing flags on this object. </p>

</div>
</div>
<a class="anchor" id="a504e2192036f75007c51e157315e1548"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::removeVisibilityFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>As setVisibilityFlags, except the flags passed as parameters are removed from the existing flags on this object. </p>

</div>
</div>
<a class="anchor" id="a8074c223d5622dd338c1ea46d9802b37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::MovableObject::getVisibilityFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the visibility flags relevant for this object. </p>

</div>
</div>
<a class="anchor" id="ac2904cb122ab8c8d5066abefb29dfa96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::MovableObject::setDefaultVisibilityFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the default visibility flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances. </p>

</div>
</div>
<a class="anchor" id="a2eb94fea5944cf0d33702a75cfa14a74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::MovableObject::getDefaultVisibilityFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the default visibility flags for all future <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> instances. </p>

</div>
</div>
<a class="anchor" id="ab55eab7ca8e96a3bbb3f69a4095bf067"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_movable_object_1_1_listener.html">Listener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a listener for this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Note for size and performance reasons only one listener per object is allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c8f2ff3a40138fa21d0058892a4db74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_movable_object_1_1_listener.html">Listener</a>* Ogre::MovableObject::getListener </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the current listener for this object. </p>

</div>
</div>
<a class="anchor" id="ab36b81e590cb83df86ba68f8b0b2c5c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; Ogre::MovableObject::queryLights </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a list of lights, ordered relative to how close they are to this movable object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>By default, this method gives the listener a chance to populate light list first, if there is no listener or <a class="el" href="class_ogre_1_1_movable_object_1_1_listener.html#ad53d3feb40d1d1fb81db1cb620df6d8e" title="Called when the movable object needs to query a light list. ">Listener::objectQueryLights</a> returns NULL, it'll query the light list from parent entity if it is present, or returns <a class="el" href="class_ogre_1_1_scene_node.html#ac3b6be9d72acfce2608b081f63df9df0" title="Allows retrieval of the nearest lights to the centre of this SceneNode. ">SceneNode::findLights</a> if it has parent scene node, otherwise it just returns an empty list. </dd></dl>
<dl class="section user"><dt></dt><dd>The object internally caches the light list, so it will recalculate it only when object is moved, or lights that affect the frustum have been changed (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a4e9e8558a06d7bf26eadf349731f1cb3" title="Advance method to gets the lights dirty counter. ">SceneManager::_getLightsDirtyCounter</a>), but if listener exists, it will be called each time, so the listener should implement their own cache mechanism to optimise performance. </dd></dl>
<dl class="section user"><dt></dt><dd>This method can be useful when implementing <a class="el" href="class_ogre_1_1_renderable.html#a91a5cc5e517b7c79fa510b9fdcc98691" title="Gets a list of lights, ordered relative to how close they are to this renderable. ...">Renderable::getLights</a> in case the renderable is a part of the movable. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The list of lights use to lighting this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a59a96239224e96845b323fb73fed8bff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::MovableObject::getLightMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a bitwise mask which will filter the lights affecting this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>By default, this mask is fully set meaning all lights will affect this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5456ecd630d55c91b2fd1b19969d29f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setLightMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>lightMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a bitwise mask which will filter the lights affecting this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This mask will be compared against the mask held against <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> to determine if a light should affect a given object. By default, this mask is fully set meaning all lights will affect this object </dd></dl>

</div>
</div>
<a class="anchor" id="a5b0982f88226f7793a9b289d33e4621f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>* Ogre::MovableObject::_getLightList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the current list of lights for this object. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You should not modify this list outside of <a class="el" href="class_ogre_1_1_movable_object_1_1_listener.html#ad53d3feb40d1d1fb81db1cb620df6d8e" title="Called when the movable object needs to query a light list. ">MovableObject::Listener::objectQueryLights</a> (say if you want to use it to implement this method, and use the pointer as a return value) and for reading it's only accurate as at the last frame. </dd></dl>

</div>
</div>
<a class="anchor" id="af061175eb50a6aa98599ce0a748204b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::MovableObject::getLightCapBounds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden member from <a class="el" href="class_ogre_1_1_shadow_caster.html" title="This class defines the interface that must be implemented by shadow casters. ">ShadowCaster</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#ad792b8137f18ea000c5bcbc5ae48814a">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="af06612d0607ebcf1bf5eb817c3038d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::MovableObject::getDarkCapBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_light.html">Light</a> &amp;&#160;</td>
          <td class="paramname"><em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>dirLightExtrusionDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overridden member from <a class="el" href="class_ogre_1_1_shadow_caster.html" title="This class defines the interface that must be implemented by shadow casters. ">ShadowCaster</a>. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#aaa198e27c2c631a41f8f5f51ad7d7261">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="acbfc4840224e8b6ed6e27849d3341675"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setCastShadows </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not this object will cast shadows. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This setting simply allows you to turn on/off shadows for a given object. An object will not cast shadows unless the scene supports it in any case (see <a class="el" href="class_ogre_1_1_scene_manager.html#a0f8f32d176059a385527cf9970ddc892" title="Sets the general shadow technique to be used in this scene. ">SceneManager::setShadowTechnique</a>), and also the material which is in use must also have shadow casting enabled. By default all entities cast shadows. If, however, for some reason you wish to disable this for a single object then you can do so using this method. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method normally refers to objects which block the light, but since <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Light</a> is also a subclass of <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>, in that context it means whether the light causes shadows itself. </dd></dl>

</div>
</div>
<a class="anchor" id="a70bca10cdeac93142d9f93ed0cf9c4c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::MovableObject::getCastShadows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether shadow casting is enabled for this object. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#a35d47283265f36187263b2738e16c563">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="a8f2627b8d1658838a7c79c82148c6303"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::MovableObject::getReceivesShadows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> of any <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> that this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will add to the render queue will receive shadows. </p>

</div>
</div>
<a class="anchor" id="abb13b8e1b52d9dca9f5190f718686a5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::MovableObject::getPointExtrusionDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_light.html">Light</a> *&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the distance to extrude for a point/spot light. </p>

<p>Implements <a class="el" href="class_ogre_1_1_shadow_caster.html#a7f8a7e2e3a9876a8453e054335d7d23c">Ogre::ShadowCaster</a>.</p>

</div>
</div>
<a class="anchor" id="a32c637889b8a4138d2008aece76f42b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::MovableObject::getTypeFlags </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the 'type flags' for this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>A type flag identifies the type of the <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> as a bitpattern. This is used for categorical inclusion / exclusion in <a class="el" href="class_ogre_1_1_scene_query.html" title="A class for performing queries on a scene. ">SceneQuery</a> objects. By default, this method returns all ones for objects not created by a <a class="el" href="class_ogre_1_1_movable_object_factory.html" title="Interface definition for a factory class which produces a certain kind of MovableObject, and can be registered with Root in order to allow all clients to produce new instances of this object, integrated with the standard Ogre processing. ">MovableObjectFactory</a> (hence always including them); otherwise it returns the value assigned to the <a class="el" href="class_ogre_1_1_movable_object_factory.html" title="Interface definition for a factory class which produces a certain kind of MovableObject, and can be registered with Root in order to allow all clients to produce new instances of this object, integrated with the standard Ogre processing. ">MovableObjectFactory</a>. Custom objects which don't use <a class="el" href="class_ogre_1_1_movable_object_factory.html" title="Interface definition for a factory class which produces a certain kind of MovableObject, and can be registered with Root in order to allow all clients to produce new instances of this object, integrated with the standard Ogre processing. ">MovableObjectFactory</a> will need to override this if they want to be included in queries. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_billboard_set.html#ab413ee6f413a7ea91a4f6f74e7986bc0">Ogre::BillboardSet</a>, <a class="el" href="class_ogre_1_1_entity.html#a14ace86637fc9e265272de3d9faee514">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_particle_system.html#a9807ca556bce7e2b13ad8c55aa455b57">Ogre::ParticleSystem</a>, <a class="el" href="class_ogre_1_1_frustum.html#a4bdabd62e2f82bbec5fbce7e16afaf08">Ogre::Frustum</a>, <a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html#af8a4495e56e9df43e1264605dc7b6424">Ogre::StaticGeometry::Region</a>, and <a class="el" href="class_ogre_1_1_light.html#a12fb2e2d60489902792ed3804e55bc3d">Ogre::Light</a>.</p>

</div>
</div>
<a class="anchor" id="acaa798ac114550b95d04fb0798ba1d94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::MovableObject::setDebugDisplayEnabled </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether or not the debug display of this object is enabled. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Some objects aren't visible themselves but it can be useful to display a debug representation of them. Or, objects may have an additional debug display on top of their regular display. This option enables / disables that debug display. Objects that are not visible never display debug geometry regardless of this setting. </dd></dl>

</div>
</div>
<a class="anchor" id="a146a71f594b7867c6c011e7c691d47f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::MovableObject::isDebugDisplayEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets whether debug display of this object is enabled. </p>

</div>
</div>
<a class="anchor" id="a55f1de18b85d2d276b2ea38a138b4e3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::ShadowCaster::clearShadowRenderableList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_shadow_caster.html#ad84ea1b2728ced5136add26c91c39a27">ShadowRenderableList</a> &amp;&#160;</td>
          <td class="paramname"><em>shadowRenderables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common implementation of releasing shadow renderables. </p>

</div>
</div>
<a class="anchor" id="acae2215c051989d544f34083a0a9bfa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ogre::ShadowCaster::extrudeVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_hardware_vertex_buffer_shared_ptr.html">HardwareVertexBufferSharedPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>originalVertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector4.html">Vector4</a> &amp;&#160;</td>
          <td class="paramname"><em>lightPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>extrudeDist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility method for extruding vertices based on a light. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Unfortunately, because D3D cannot handle homogeneous (4D) position coordinates in the fixed-function pipeline (GL can, but we have to be cross-API), when we extrude in software we cannot extrude to infinity the way we do in the vertex program (by setting w to 0.0f). Therefore we extrude by a fixed distance, which may cause some problems with larger scenes. Luckily better hardware (ie vertex programs) can fix this. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexBuffer</td><td>The vertex buffer containing ONLY xyz position values, which must be originalVertexCount * 2 * 3 floats long. </td></tr>
    <tr><td class="paramname">originalVertexCount</td><td>The count of the original number of vertices, i.e. the number in the mesh, not counting the doubling which has already been done (by <a class="el" href="class_ogre_1_1_vertex_data.html#a35751c0e63acf6def8a1cf101abd1b28" title="Modifies the vertex data to be suitable for use for rendering shadow geometry. ">VertexData::prepareForShadowVolume</a>) to provide the extruded area of the buffer. </td></tr>
    <tr><td class="paramname">lightPos</td><td>4D light position in object space, when w=0.0f this represents a directional light. </td></tr>
    <tr><td class="paramname">extrudeDist</td><td>The distance to extrude. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4239d192b2b08c4970dfaa22ce5a0cd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group___general.html#ga0899c03496d3c25c6555889aa76a78db">StringVector</a>&amp; Ogre::AnimableObject::getAnimableValueNames </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a list of animable value names for this object. </p>

<p>References <a class="el" href="class_ogre_1_1_exception.html#a9bdf9b8a0a83b95818d676848beaa29ba9f57f8f4aefb7fae5fcd69fe155e7003">Ogre::Exception::ERR_ITEM_NOT_FOUND</a>, and <a class="el" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>.</p>

</div>
</div>
<a class="anchor" id="ab2cfac9af1b0d71c780ec969166b3585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#a5e0882c3b9f7ca32a795f98cf034e428">AnimableValuePtr</a> Ogre::AnimableObject::createAnimableValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>valueName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a reference-counted AnimableValuePtr for the named value. </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can use the returned object to animate a value on this object, using <a class="el" href="class_ogre_1_1_animation_track.html" title="A &#39;track&#39; in an animation sequence, i.e. ">AnimationTrack</a>. Subclasses must override this if they wish to support animation of their values. </dd></dl>

<p>Reimplemented in <a class="el" href="class_ogre_1_1_light.html#a6e0be3df5d41752c0bedfcf9c89e492b">Ogre::Light</a>.</p>

<p>References <a class="el" href="class_ogre_1_1_exception.html#a9bdf9b8a0a83b95818d676848beaa29ba9f57f8f4aefb7fae5fcd69fe155e7003">Ogre::Exception::ERR_ITEM_NOT_FOUND</a>, and <a class="el" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_manual_object_8h.html">OgreManualObject.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_manual_object.html">ManualObject</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
